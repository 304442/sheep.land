<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PB Setup: Sheep Land</title>
    <script src="https://unpkg.com/pocketbase@latest/dist/pocketbase.umd.js"></script>
    <style>
        body{font-family:sans-serif;font-size:13px;line-height:1.4;padding:10px;background:#f0f0f0;color:#333;display:flex;flex-direction:column;align-items:center;margin:0;}
        .c{max-width:700px;width:100%;background:white;padding:15px;border-radius:5px;box-shadow:0 2px 8px rgba(0,0,0,0.1);}
        h1{color:#333;border-bottom:1px solid #ccc;padding-bottom:5px;margin:0 0 10px 0;font-size:1.2em;}
        p{font-size:0.9em;margin:0 0 0.5em 0;} .warn{color:red;font-weight:bold;}
        button{padding:6px 10px;background:#007bff;color:white;border:0;border-radius:3px;cursor:pointer;font-size:0.85em;margin-bottom:5px;}
        button:disabled{background:#ccc;} button:hover:not(:disabled){background:#0056b3;}
        #out{margin-top:10px;padding:8px;background:#222;color:#eee;border-radius:3px;white-space:pre-wrap;font-family:monospace;font-size:11px;max-height:70vh;overflow-y:auto;}
        .ls{color:lime;font-weight:bold;}
        .le{color:salmon;font-weight:bold;}
        .li{color:cyan;}
        .lw{color:yellow;}
        .ld{color:gray;}
        #out pre { margin-top: 5px; padding: 5px; background-color: #333; border-radius: 3px; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="c">
        <h1>PB Sheep Land Setup</h1>
        <p class="warn">WARNING: This script uses default admin credentials (admin@example.com / unifiedpassword). CHANGE THESE IMMEDIATELY in a production environment. This script will create/update collections and data. Backup your existing data if necessary before running.</p>
        <button id="runFullSetup">Run Full Setup</button>
        <button id="runSchemaOnly">Schema Only</button>
        <button id="runSeedOnly" disabled>Seed Data Only</button>
        <div id="out"></div>
    </div>
<script>
    const pbUrl = '/';
    const outputDiv = document.getElementById('out');
    const runFullSetupButton = document.getElementById('runFullSetup');
    const runSchemaOnlyButton = document.getElementById('runSchemaOnly');
    const runSeedOnlyButton = document.getElementById('runSeedOnly');
    const ADM_E = 'admin@example.com';
    const ADM_P = 'unifiedpassword';

    const log = (message, type = 'i', data = null) => {
        const timestamp = `[${new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' })}] `;
        const p = document.createElement('p');
        p.className = `l${type[0].toLowerCase()}`;
        let logMessage = timestamp + message.replace(/</g, '<').replace(/>/g, '>');
        if (data) {
            const pre = document.createElement('pre');
            pre.className = 'ld'; 
            pre.textContent = JSON.stringify(data, null, 2);
            logMessage += "\n" + pre.outerHTML; 
        }
        p.innerHTML = logMessage; 
        outputDiv.appendChild(p);
        outputDiv.scrollTop = outputDiv.scrollHeight;
        
        const consoleMessage = timestamp + message.replace(/<[^>]*>?/gm, ''); 
        if (type === 'e') console.error(consoleMessage, data || '');
        else if (type === 'w') console.warn(consoleMessage, data || '');
        else if (type === 'd') console.debug(consoleMessage, data || '');
        else console.log(consoleMessage, data || '');
    };

    async function authenticateAdmin(pb) {
        try {
            await pb.admins.authWithPassword(ADM_E, ADM_P);
            log('Admin authentication successful', 's');
            return true;
        } catch (error) {
            log(`Admin authentication failed: ${error.message}`, 'e');
            return false;
        }
    }
    
    const defaultRefundPolicyHTMLForSeed = `
        <div class="bil-row">
            <p class="en">Welcome to Sheep Land. We strive to provide the best quality Udheya and livestock services. Please read our policy carefully.</p>
            <p class="ar" dir="rtl">مرحباً بكم في أرض الأغنام. نسعى جاهدين لتقديم أفضل جودة في خدمات الأضاحي والمواشي. يرجى قراءة سياستنا بعناية.</p>
        </div>
        <h3 class="bil-spread modal-section-title">
            <span class="en">Udheya Orders</span><span class="ar" dir="rtl">طلبات الأضاحي</span>
        </h3>
        <div class="bil-row">
            <p class="en">Due to the nature of Udheya (Qurbani/Sacrifice), which is a time-sensitive religious observance, our refund and cancellation policy is as follows:</p>
            <p class="ar" dir="rtl">نظرًا لطبيعة الأضحية، وهي شعيرة دينية مرتبطة بوقت محدد، فإن سياسة الاسترداد والإلغاء لدينا هي كما يلي:</p>
        </div>
        <ul class="modal-list">
            <li><div class="bil-row"><p class="en"><strong>Cancellations Before Cut-off:</strong> Full refund available before specified deadline, minus payment processing fees.</p><p class="ar" dir="rtl"><strong>الإلغاء قبل الموعد النهائي:</strong> استرداد كامل متاح قبل الموعد النهائي المحدد، مخصومًا منه رسوم معالجة الدفع.</p></div></li>
            <li><div class="bil-row"><p class="en"><strong>Cancellations After Cut-off:</strong> Non-refundable once animal is allocated and preparations begin.</p><p class="ar" dir="rtl"><strong>الإلغاء بعد الموعد النهائي:</strong> غير قابل للاسترداد بمجرد تخصيص الحيوان وبدء الاستعدادات.</p></div></li>
            <li><div class="bil-row"><p class="en"><strong>Non-Fulfilment by Sheep Land:</strong> Full refund if we cannot fulfill confirmed orders due to unforeseen circumstances.</p><p class="ar" dir="rtl"><strong>عدم التنفيذ من قبل أرض الأغنام:</strong> استرداد كامل إذا لم نتمكن من تلبية الطلبات المؤكدة بسبب ظروف غير متوقعة.</p></div></li>
        </ul>
        <h3 class="bil-spread modal-section-title"><span class="en">Other Products</span><span class="ar" dir="rtl">منتجات أخرى</span></h3>
        <div class="bil-row"><p class="en">For livestock, meat cuts, and gathering packages: cancellations typically allowed up to 48 hours before delivery. Quality issues should be reported within 12-24 hours with photographic evidence.</p><p class="ar" dir="rtl">للمواشي وقطعيات اللحوم وباقات الولائم: يُسمح بالإلغاء عادةً حتى 48 ساعة قبل التوصيل. يجب الإبلاغ عن مشاكل الجودة خلال 12-24 ساعة مع دليل فوتوغرافي.</p></div>
    `;

    const collectionsDefinition = [
        {
            name: "settings",
            type: "base",
            system: false,
            listRule: "", 
            viewRule: "", 
            createRule: null, 
            updateRule: "@request.auth.id != '' && @request.auth.verified = true", 
            deleteRule: null, 
            fields: [ 
                { name: "xchgRates", type: "json", required: true, presentable: true }, 
                { name: "defCurr", type: "text", required: true, presentable: true, max: 5, min: 3 },
                { name: "waNumRaw", type: "text", required: false, presentable: true, max: 20 }, 
                { name: "waNumDisp", type: "text", required: false, presentable: true, max: 30 },
                { name: "promoEndISO", type: "date", required: false, presentable: true }, 
                { name: "promoDiscPc", type: "number", required: false, presentable: true, min: 0, max: 100 },
                { name: "promoActive", type: "bool", required: false, presentable: true }, 
                { name: "servFeeEGP", type: "number", required: true, presentable: true, min: 0 },
                { name: "delAreas", type: "json", required: false, presentable: true }, 
                { name: "payDetails", type: "json", required: false, presentable: true },
                { name: "enable_udheya_section", type: "bool", required: false, presentable: true }, 
                { name: "enable_livestock_section", type: "bool", required: false, presentable: true },
                { name: "enable_meat_section", type: "bool", required: false, presentable: true }, 
                { name: "enable_gatherings_section", type: "bool", required: false, presentable: true },
                { name: "slaughter_location_gmaps_url", type: "url", required: false, presentable: true },
                { name: "online_payment_fee_egp", type: "number", required: false, presentable: true, min: 0 },
                { name: "refund_policy_html", type: "editor", required: false, presentable: false }, 
                { name: "app_email_sender_address", type: "email", required: false, presentable: false },
                { name: "app_email_sender_name", type: "text", required: false, presentable: false, max: 100 }
            ]
        },
        {
            name: "products", 
            type: "base", 
            system: false,
            listRule: "", 
            viewRule: "", 
            createRule: "@request.auth.id != '' && @request.auth.verified = true", 
            updateRule: "@request.auth.id != '' && @request.auth.verified = true", 
            deleteRule: "@request.auth.id != '' && @request.auth.verified = true",
            fields: [
                { name: "item_key", type: "text", required: true, presentable: true, unique: true, max: 100, min: 1, pattern: "^[a-z0-9_]+$" },
                { name: "product_category", type: "select", required: true, presentable: true, maxSelect: 1, values: ["udheya", "livestock_general", "meat_cuts", "gathering_package", "other"] },
                { name: "type_key", type: "text", required: true, presentable: true, max: 50, min: 1, pattern: "^[a-z0-9_]+$" },
                { name: "type_name_en", type: "text", required: true, presentable: true, max: 100, min: 1 }, 
                { name: "type_name_ar", type: "text", required: true, presentable: true, max: 100, min: 1 },
                { name: "type_description_en", type: "text", required: false, presentable: true, max: 300 }, 
                { name: "type_description_ar", type: "text", required: false, presentable: true, max: 300 },
                { name: "price_per_kg_egp", type: "number", required: false, presentable: true, min: 0 },
                { name: "variant_name_en", type: "text", required: true, presentable: true, max: 150, min: 1 },
                { name: "variant_name_ar", type: "text", required: true, presentable: true, max: 150, min: 1 }, 
                { name: "weight_range_text_en", type: "text", required: false, presentable: true, max: 50 },
                { name: "weight_range_text_ar", type: "text", required: false, presentable: true, max: 50 }, 
                { name: "avg_weight_kg", type: "number", required: false, presentable: true, min: 0 },
                { name: "base_price_egp", type: "number", required: true, presentable: true, min: 0 }, 
                { name: "stock_available_pb", type: "number", required: true, presentable: true, min: 0, noDecimal: true },
                { name: "is_active", type: "bool", required: false, presentable: true }, 
                { name: "sort_order_type", type: "number", required: false, presentable: true, min: 0, noDecimal: true },
                { name: "sort_order_variant", type: "number", required: false, presentable: true, min: 0, noDecimal: true }
            ],
            indexes: [ "CREATE UNIQUE INDEX `idx_products_item_key` ON `products` (`item_key`)", "CREATE INDEX `idx_products_category` ON `products` (`product_category`)" ]
        },
        { 
            name: "users",
            type: "auth",
            system: false, 
            listRule: "@request.auth.id = id || @request.auth.admin = true",
            viewRule: "@request.auth.id = id || @request.auth.admin = true",
            createRule: "", 
            updateRule: "@request.auth.id = id || @request.auth.admin = true", 
            deleteRule: "@request.auth.id = id || @request.auth.admin = true", 
            options: { 
                emailVisibility: true, 
                requireEmailVerification: false, 
                allowOAuth2Auth: false,
                allowUsernameAuth: false, 
                allowPasswordAuth: true,
                onlyVerified: false 
            },
            fields: [ 
                { name: "name", type: "text", required: false, presentable: true, max: 100 }
            ]
        },
        { 
            name: "orders", 
            type: "base", 
            system: false,
            listRule: "@request.query.lookupOrderID != '' && order_id_text = @request.query.lookupOrderID", 
            viewRule: "@request.query.lookupOrderID != '' && order_id_text = @request.query.lookupOrderID",
            createRule: "", 
            updateRule: "@request.auth.id != '' && @request.auth.verified = true", 
            deleteRule: "@request.auth.id != '' && @request.auth.verified = true", 
            fields: [
                { name: "order_id_text", type: "text", required: true, presentable: true, unique: true, max: 50, min: 1 },
                { name: "customer_name", type: "text", required: true, presentable: true, max: 150, min: 1 },
                { name: "customer_phone", type: "text", required: true, presentable: true, max: 30, min: 7 },
                { name: "customer_email", type: "email", required: true, presentable: true },
                { name: "line_items", type: "json", required: true, presentable: true }, 
                { name: "delivery_option", type: "select", required: true, presentable: true, maxSelect: 1, values: ["home_delivery", "self_pickup_or_internal_distribution"] },
                { name: "delivery_city_id", type: "text", required: false, presentable: true, max: 50 },
                { name: "delivery_area_name_en", type: "text", required: false, presentable: true, max: 100 },
                { name: "delivery_area_name_ar", type: "text", required: false, presentable: true, max: 100 },
                { name: "delivery_address", type: "text", required: false, presentable: true, max: 500 },
                { name: "delivery_instructions", type: "text", required: false, presentable: true, max: 500 },
                { name: "delivery_time_slot", type: "text", required: false, presentable: true, max: 50 },
                { name: "payment_method", type: "text", required: true, presentable: true, max: 50, min: 1 },
                { name: "payment_status", type: "select", required: true, presentable: true, maxSelect: 1, values: ["pending_payment", "payment_under_review", "paid_confirmed", "cod_pending_confirmation", "cod_confirmed_pending_delivery", "failed", "refunded", "partially_refunded", "pending_gateway_redirect"] },
                { name: "order_status", type: "select", required: true, presentable: true, maxSelect: 1, values: ["pending_confirmation", "confirmed_pending_payment", "payment_confirmed_processing", "ready_for_fulfillment", "out_for_delivery", "fulfilled_completed", "cancelled_by_user", "cancelled_by_admin", "on_hold", "awaiting_payment_gateway"] },
                { name: "terms_agreed", type: "bool", required: true, presentable: true },
                { name: "admin_notes", type: "editor", required: false, presentable: false },
                { name: "user_ip_address", type: "text", required: false, presentable: false, max: 50 },
                { name: "user_agent_string", type: "text", required: false, presentable: false, max: 300 },
                { name: "subtotal_amount_egp", type: "number", required: true, presentable: true, min: 0 },
                { name: "total_udheya_service_fee_egp", type: "number", required: false, presentable: true, min: 0 },
                { name: "delivery_fee_applied_egp", type: "number", required: false, presentable: true, min: 0 },
                { name: "online_payment_fee_applied_egp", type: "number", required: false, presentable: true, min: 0 },
                { name: "total_amount_due_egp", type: "number", required: true, presentable: true, min: 0 },
                { name: "selected_display_currency", type: "text", required: false, presentable: true, max: 5 }
            ],
            indexes: [ "CREATE UNIQUE INDEX `idx_orders_order_id_text` ON `orders` (`order_id_text`)" ]
        }
    ];

    const seedData = {
        settings: [{
            xchgRates: { EGP: { rate_from_egp: 1, symbol: "LE", is_active: true }, USD: { rate_from_egp: 0.020, symbol: "$", is_active: true }, GBP: { rate_from_egp: 0.015, symbol: "£", is_active: true }, EUR: { rate_from_egp: 0.018, symbol: "€", is_active: true } },
            defCurr: "EGP", waNumRaw: "201117117489", waNumDisp: "+20 11 1711 7489", 
            promoEndISO: new Date(Date.now() + 15 * 24 * 60 * 60 * 1000).toISOString(), 
            promoDiscPc: 10, promoActive: true, servFeeEGP: 750,
            delAreas: [ { id: "giza_west", name_en: "Giza West", name_ar: "غرب الجيزة", cities: [ { id: "october", name_en: "6th of October City", name_ar: "مدينة 6 أكتوبر", delivery_fee_egp: 150 }, { id: "zayed", name_en: "Sheikh Zayed", name_ar: "الشيخ زايد", delivery_fee_egp: 150 }, { id: "hadayek_october", name_en: "Hadayek October", name_ar: "حدائق أكتوبر", delivery_fee_egp: 120 } ] }, { id:"cairo_east", name_en:"Cairo East", name_ar:"شرق القاهرة", cities:[ {id:"tagamoa", name_en:"New Cairo (Tagamoa)", name_ar:"التجمع (القاهرة الجديدة)", delivery_fee_egp: 250 }, {id:"madinaty", name_en:"Madinaty", name_ar:"مدينتي", delivery_fee_egp: 300 }, {id:"shorouk", name_en:"El Shorouk", name_ar:"الشروق", delivery_fee_egp: 300} ] } ],
            payDetails: { vodafone_cash: "01076543210", instapay_ipn: "seed_user@instapay", revolut_details: "@seedUserRevolut", monzo_details: "monzo.me/seeduser", bank_name: "Seed Bank Egypt", bank_account_name: "Sheep Land Seed Account", bank_account_number: "1234567890123456", bank_iban: "EG00123400000000001234567890", bank_swift: "SEEDBANKEGCA" },
            enable_udheya_section: true, enable_livestock_section: true, enable_meat_section: true, enable_gatherings_section: true,
            slaughter_location_gmaps_url: "https://maps.app.goo.gl/GmWajZfqzPh4ZAey7", online_payment_fee_egp: 35,
            refund_policy_html: defaultRefundPolicyHTMLForSeed, app_email_sender_address: "noreply@sheepland.example.com", app_email_sender_name: "Sheep Land Orders"
        }],
        products: [
            { item_key: "baladi_udheya_45kg", product_category: "udheya", type_key: "baladi", type_name_en: "Baladi Udheya Sheep", type_name_ar: "خروف بلدي للأضحية", type_description_en: "Local breed, excellent for Udheya, known for its marbling and taste.", type_description_ar: "سلالة محلية، ممتازة للأضحية، معروفة بدهونها المتداخلة وطعمها الغني.", price_per_kg_egp: 230, variant_name_en: "Baladi Udheya (Approx. 45kg)", variant_name_ar: "أضحية بلدي (تقريباً ٤٥ كجم)", weight_range_text_en: "40-50kg", weight_range_text_ar: "٤٠-٥٠ كجم", avg_weight_kg: 45, base_price_egp: 10350, stock_available_pb: 10, is_active: true, sort_order_type: 1, sort_order_variant: 1 },
            { item_key: "baladi_udheya_55kg", product_category: "udheya", type_key: "baladi", type_name_en: "Baladi Udheya Sheep", type_name_ar: "خروف بلدي للأضحية", type_description_en: "Larger local breed, excellent for Udheya.", type_description_ar: "سلالة محلية أكبر حجمًا، ممتازة للأضحية.", price_per_kg_egp: 230, variant_name_en: "Baladi Udheya (Approx. 55kg)", variant_name_ar: "أضحية بلدي (تقريباً ٥٥ كجم)", weight_range_text_en: "50-60kg", weight_range_text_ar: "٥٠-٦٠ كجم", avg_weight_kg: 55, base_price_egp: 12650, stock_available_pb: 8, is_active: true, sort_order_type: 1, sort_order_variant: 2 },
            { item_key: "barki_udheya_50kg", product_category: "udheya", type_key: "barki", type_name_en: "Barki Udheya Sheep", type_name_ar: "خروف برقي للأضحية", type_description_en: "Desert breed, lean and flavorful meat, popular for Udheya.", type_description_ar: "سلالة صحراوية، لحم قليل الدهن وذو نكهة مميزة، شائع للأضحية.", price_per_kg_egp: 250, variant_name_en: "Barki Udheya (Approx. 50kg)", variant_name_ar: "أضحية برقي (تقريباً ٥٠ كجم)", weight_range_text_en: "45-55kg", weight_range_text_ar: "٤٥-٥٥ كجم", avg_weight_kg: 50, base_price_egp: 12500, stock_available_pb: 12, is_active: true, sort_order_type: 2, sort_order_variant: 1 },
            { item_key: "live_ram_baladi_large", product_category: "livestock_general", type_key: "baladi", type_name_en: "Live Baladi Ram", type_name_ar: "كبش بلدي حي", type_description_en: "Large healthy Baladi ram for breeding or other purposes.", type_description_ar: "كبش بلدي كبير صحي للتربية أو أغراض أخرى.", variant_name_en: "Large Baladi Ram (70-80kg)", variant_name_ar: "كبش بلدي كبير (٧٠-٨٠كجم)", base_price_egp: 15000, stock_available_pb: 3, is_active: true, sort_order_type: 3, sort_order_variant: 1 },
            { item_key: "live_ewe_barki_medium", product_category: "livestock_general", type_key: "barki", type_name_en: "Live Barki Ewe", type_name_ar: "نعجة برقي حية", type_description_en: "Healthy Barki ewe, excellent for breeding programs.", type_description_ar: "نعجة برقي صحية، ممتازة لبرامج التربية.", variant_name_en: "Medium Barki Ewe (50-60kg)", variant_name_ar: "نعجة برقي متوسطة (٥٠-٦٠كجم)", base_price_egp: 9500, stock_available_pb: 5, is_active: true, sort_order_type: 3, sort_order_variant: 2 },
            { item_key: "lamb_chops_kg", product_category: "meat_cuts", type_key: "lamb_cuts", type_name_en: "Lamb Cuts", type_name_ar: "قطعيات ضأن", type_description_en: "Fresh premium lamb chops, tender and juicy.", type_description_ar: "ريش ضأن طازجة فاخرة، طرية وغنية بالعصارة.", variant_name_en: "Lamb Chops (per kg)", variant_name_ar: "ريش ضاني (للكيلو)", weight_range_text_en: "Per kg", weight_range_text_ar: "للكيلو", base_price_egp: 450, stock_available_pb: 15, is_active: true, sort_order_type: 4, sort_order_variant: 1 },
            { item_key: "lamb_leg_whole", product_category: "meat_cuts", type_key: "lamb_cuts", type_name_en: "Lamb Cuts", type_name_ar: "قطعيات ضأن", type_description_en: "Whole lamb leg, perfect for roasting or special meals.", type_description_ar: "فخذة ضأن كاملة، مثالية للتحمير أو الوجبات الخاصة.", variant_name_en: "Whole Lamb Leg (Approx. 2-3kg)", variant_name_ar: "فخذة ضاني كاملة (تقريباً ٢-٣ كجم)", avg_weight_kg: 2.5, base_price_egp: 1100, stock_available_pb: 7, is_active: true, sort_order_type: 4, sort_order_variant: 2 },
            { item_key: "beef_mince_kg", product_category: "meat_cuts", type_key: "beef_cuts", type_name_en: "Beef Cuts", type_name_ar: "قطعيات بقري", type_description_en: "Freshly ground local beef, versatile for many dishes.", type_description_ar: "لحم بقري محلي مفروم طازج، متعدد الاستخدامات للعديد من الأطباق.", variant_name_en: "Beef Mince (per kg)", variant_name_ar: "لحم بقري مفروم (للكيلو)", weight_range_text_en: "Per kg", weight_range_text_ar: "للكيلو", base_price_egp: 380, stock_available_pb: 20, is_active: true, sort_order_type: 4, sort_order_variant: 3 },
            { item_key: "gathering_feast_medium", product_category: "gathering_package", type_key: "feast_pack", type_name_en: "Medium Feast Package", type_name_ar: "باقة وليمة متوسطة", type_description_en: "Complete package for a medium gathering. Includes one processed sheep (approx 50kg live weight), rice, and salads.", type_description_ar: "باقة متكاملة لوليمة متوسطة. تشمل خروف مجهز (وزن حي تقريباً ٥٠ كجم)، أرز، وسلطات.", variant_name_en: "Medium Feast (serves 15-20)", variant_name_ar: "وليمة متوسطة (تكفي ١٥-٢٠ فرد)", base_price_egp: 14500, stock_available_pb: 5, is_active: true, sort_order_type: 5, sort_order_variant: 1 },
            { item_key: "gathering_bbq_large", product_category: "gathering_package", type_key: "bbq_pack", type_name_en: "Large BBQ Package", type_name_ar: "باقة شواء كبيرة", type_description_en: "Generous assortment of marinated meats, skewers, and sides for a large BBQ event.", type_description_ar: "تشكيلة وفيرة من اللحوم المتبلة، الأسياخ، والأطباق الجانبية لحفل شواء كبير.", variant_name_en: "Large BBQ Pack (serves 20-25)", variant_name_ar: "باقة شواء كبيرة (تكفي ٢٠-٢٥ فردًا)", base_price_egp: 4500, stock_available_pb: 8, is_active: true, sort_order_type: 5, sort_order_variant: 2 }
        ]
    };

    async function safeExecute(operation, operationName, pbInstance = null) {
        const pb = pbInstance || new PocketBase(pbUrl);
        try {
            log(`Starting ${operationName}...`, 'i');
            const result = await operation(pb);
            log(`${operationName} completed successfully.`, 's');
            return { success: true, result };
        } catch (error) {
            log(`${operationName} FAILED: ${error.message}`, 'e');
            console.error(`${operationName} error:`, error);
            if (error.response && error.response.data) {
                log('Server error details:', 'e', error.response.data);
            } else if (error.data) {
                 log('Error details:', 'e', error.data);
            }
            if (error.stack) {
                log('Stack trace:', 'd', error.stack.split('\n').slice(0, 5).join('\n'));
            }
            return { success: false, error };
        } finally {
            if (pbInstance === null && pb.authStore.isValid && pb.authStore.isAdmin) {
                log(`Clearing temporary admin auth after ${operationName}`, 'd');
                pb.authStore.clear();
            }
        }
    }

    async function setupSchema(pb) {
        if (!await authenticateAdmin(pb)) return false;

        log('Processing initial collections (settings, products, users config, orders without relations)...', 'i');
        if (!await importOrUpdateCollections(pb, collectionsDefinition)) { 
             log('Initial collection setup failed.', 'e'); return false;
        }
        
        log('Processing relation fields for "orders" collection...', 'i');
        if (!await addOrVerifyRelationFields(pb)) {
             log('Relation field setup for "orders" failed.', 'e'); return false;
        }

        log('Schema setup phase completed successfully.', 's');
        return true;
    }
    
    async function importOrUpdateCollections(pb, collectionsToProcess) {
        log('Starting collection schema setup/update for specified collections...', 'i');
        for (const collectionDef of collectionsToProcess) {
            let existingCollection = null;
            const isAuthCollection = collectionDef.name === "users";
            const collectionNameToUse = isAuthCollection ? "_pb_users_auth_" : collectionDef.name;

            try {
                existingCollection = await pb.collections.getOne(collectionNameToUse);
                log(`Collection "${collectionNameToUse}" exists. Attempting update...`, 'i');
                
                const updatePayload = {
                    listRule: collectionDef.listRule,
                    viewRule: collectionDef.viewRule,
                    createRule: collectionDef.createRule,
                    updateRule: collectionDef.updateRule,
                    deleteRule: collectionDef.deleteRule,
                    fields: collectionDef.fields,
                };
                
                if (isAuthCollection && collectionDef.options) { 
                    updatePayload.options = { ... (existingCollection.options || {}), ...collectionDef.options };
                }
                
                await pb.collections.update(collectionNameToUse, updatePayload);
                log(`Collection "${collectionNameToUse}" updated successfully.`, 's');

            } catch (e) {
                if (e.status === 404 && !isAuthCollection) { 
                    log(`Collection "${collectionDef.name}" not found. Creating...`, 'i');
                    try {
                         const newCollectionData = {
                            name: collectionDef.name,
                            type: collectionDef.type,
                            system: collectionDef.system || false,
                            fields: collectionDef.fields, 
                            listRule: collectionDef.listRule !== undefined ? collectionDef.listRule : null,
                            viewRule: collectionDef.viewRule !== undefined ? collectionDef.viewRule : null,
                            createRule: collectionDef.createRule !== undefined ? collectionDef.createRule : null,
                            updateRule: collectionDef.updateRule !== undefined ? collectionDef.updateRule : null,
                            deleteRule: collectionDef.deleteRule !== undefined ? collectionDef.deleteRule : null,
                            options: collectionDef.options || {} 
                        };
                        
                        await pb.collections.create(newCollectionData); 
                        log(`Collection "${collectionDef.name}" created successfully.`, 's');
                    } catch (createError) {
                        log(`Error CREATING collection "${collectionDef.name}": ${createError.message}`, 'e', createError.data || createError);
                        return false; 
                    }
                } else if (e.status === 404 && isAuthCollection) {
                     log(`Auth collection "${collectionNameToUse}" should exist. This error indicates a problem with PocketBase itself or the system user collection is missing.`, 'e', e.data || e);
                     return false;
                } else { 
                    log(`Error processing collection "${collectionNameToUse}": ${e.message}`, 'e', e.data || e);
                    return false; 
                }
            }
            await new Promise(r => setTimeout(r, 100));
        }
        log('Collection schema processing finished.', 's');
        return true;
    }
    
    async function addOrVerifyRelationFields(pb) {
        log('Adding/Verifying relation fields...', 'i');
        let overallSuccess = true;
        
        let usersCollectionId;
        try {
            const usersCollection = await pb.collections.getOne("_pb_users_auth_");
            usersCollectionId = usersCollection.id;
            log(`Found users collection ID: ${usersCollectionId}`, 'd');
        } catch (error) {
            log(`Failed to get users collection: ${error.message}`, 'e');
            return false;
        }
        
        const relationsToAdd = [
            { 
                sourceCollectionName: "orders", 
                fieldName: "user", 
                targetCollectionId: usersCollectionId,
                cascadeDelete: false, 
                minSelect: null, 
                maxSelect: 1, 
                displayFields: ["email", "name"],
                required: false, 
                presentable: true
            }
        ];

        for (const rel of relationsToAdd) {
            try {
                const sourceCollection = await pb.collections.getOne(rel.sourceCollectionName);
                let fields = sourceCollection.fields || [];
                const fieldExists = fields.find(f => f.name === rel.fieldName && f.type === "relation");

                if (fieldExists) {
                    log(`Relation field "${rel.fieldName}" in "${rel.sourceCollectionName}" exists. Verifying...`, 'w');
                    let fieldChanged = false;
                    
                    if (fieldExists.required !== rel.required) { fieldChanged = true; fieldExists.required = rel.required; }
                    if (fieldExists.presentable !== rel.presentable) { fieldChanged = true; fieldExists.presentable = rel.presentable; }
                    if (fieldExists.collectionId !== rel.targetCollectionId) { fieldChanged = true; fieldExists.collectionId = rel.targetCollectionId; }
                    if (fieldExists.cascadeDelete !== rel.cascadeDelete) { fieldChanged = true; fieldExists.cascadeDelete = rel.cascadeDelete; }
                    if (fieldExists.minSelect !== rel.minSelect) { fieldChanged = true; fieldExists.minSelect = rel.minSelect; }
                    if (fieldExists.maxSelect !== rel.maxSelect) { fieldChanged = true; fieldExists.maxSelect = rel.maxSelect; }
                    if (JSON.stringify(fieldExists.displayFields?.sort()) !== JSON.stringify(rel.displayFields?.sort())) {
                        fieldChanged = true;
                        fieldExists.displayFields = rel.displayFields;
                    }

                    if(fieldChanged) {
                        log(`Updating existing relation field "${rel.fieldName}" in "${rel.sourceCollectionName}".`, 'i');
                        await pb.collections.update(sourceCollection.id, { fields: fields });
                    }
                    
                    if (rel.sourceCollectionName === "orders") {
                        const currentCollection = await pb.collections.getOne(rel.sourceCollectionName);
                        const expectedListRule = "(@request.auth.id != '' && user = @request.auth.id) || (@request.query.lookupOrderID != '' && order_id_text = @request.query.lookupOrderID) || @request.auth.admin = true";
                        const expectedViewRule = "(@request.auth.id != '' && user = @request.auth.id) || (@request.query.lookupOrderID != '' && order_id_text = @request.query.lookupOrderID) || @request.auth.admin = true";
                        
                        if (currentCollection.listRule !== expectedListRule || currentCollection.viewRule !== expectedViewRule) {
                            log('Updating orders collection API rules...', 'i');
                            await pb.collections.update(sourceCollection.id, {
                                listRule: expectedListRule,
                                viewRule: expectedViewRule
                            });
                            log('Orders collection API rules updated.', 's');
                        }
                    }
                    continue;
                }
                
                const newField = {
                    name: rel.fieldName,
                    type: "relation",
                    required: rel.required,
                    presentable: rel.presentable,
                    collectionId: rel.targetCollectionId,
                    cascadeDelete: rel.cascadeDelete,
                    minSelect: rel.minSelect,
                    maxSelect: rel.maxSelect,
                    displayFields: rel.displayFields 
                };
                
                fields.push(newField);
                await pb.collections.update(sourceCollection.id, { fields: fields });
                log(`Relation field "${rel.fieldName}" added to "${rel.sourceCollectionName}" successfully.`, 's');
                
                if (rel.sourceCollectionName === "orders") {
                    log('Updating orders collection API rules with user field references...', 'i');
                    await pb.collections.update(sourceCollection.id, {
                        listRule: "(@request.auth.id != '' && user = @request.auth.id) || (@request.query.lookupOrderID != '' && order_id_text = @request.query.lookupOrderID) || @request.auth.admin = true",
                        viewRule: "(@request.auth.id != '' && user = @request.auth.id) || (@request.query.lookupOrderID != '' && order_id_text = @request.query.lookupOrderID) || @request.auth.admin = true"
                    });
                    log('Orders collection API rules updated successfully.', 's');
                }

            } catch (error) {
                log(`Error adding/verifying relation field "${rel.fieldName}" to "${rel.sourceCollectionName}": ${error.message}`, 'e', error.data || error);
                overallSuccess = false;
            }
            await new Promise(r => setTimeout(r, 100)); 
        }
        return overallSuccess;
    }

    async function seedCollectionData(pb, collectionName, seedItems, uniqueKeyField = null) {
        log(`Seeding data for ${collectionName}...`, 'i');
        let createdCount = 0, updatedCount = 0, errorCount = 0;
        
        for (const item of seedItems) {
            try {
                let existingRecord = null;
                if (uniqueKeyField && item[uniqueKeyField] !== undefined) { 
                    try { 
                        existingRecord = await pb.collection(collectionName).getFirstListItem(`${uniqueKeyField}="${pb.utils.escapeFilterValue(item[uniqueKeyField])}"`); 
                    } catch (e) { /* Record doesn't exist, will create */ }
                } else if (!uniqueKeyField && collectionName === "settings") { 
                    const list = await pb.collection(collectionName).getList(1, 1);
                    if (list.items.length > 0) existingRecord = list.items[0];
                }

                if (existingRecord) {
                    await pb.collection(collectionName).update(existingRecord.id, item);
                    updatedCount++;
                } else {
                    await pb.collection(collectionName).create(item);
                    createdCount++;
                }
            } catch (error) {
                log(`Error processing item in ${collectionName} (${item[uniqueKeyField] || 'new item'}): ${error.message}`, 'e');
                console.error('Seed error:', error);
                if (error.response?.data) log('Seed error details:', 'e', error.response.data);
                errorCount++;
            }
        }
        log(`Seeding ${collectionName} complete. Created: ${createdCount}, Updated: ${updatedCount}, Errors: ${errorCount}`, errorCount > 0 ? 'w' : 's');
        return { created: createdCount, updated: updatedCount, errors: errorCount };
    }

    async function setupSeedData(pb) {
        log('=== SEED DATA PHASE ===', 'i');
        if (!await authenticateAdmin(pb)) return false;

        log('Pausing for 1 second before seeding...', 'i');
        await new Promise(resolve => setTimeout(resolve, 1000));

        let anySeedErrors = false;
        const settingsResult = await seedCollectionData(pb, 'settings', seedData.settings);
        if(settingsResult.errors > 0) anySeedErrors = true;

        const productsResult = await seedCollectionData(pb, 'products', seedData.products, 'item_key');
        if(productsResult.errors > 0) anySeedErrors = true;
        
        if (anySeedErrors) {
            log('Seed data setup completed with errors.', 'w');
            return false; 
        }
        log('Seed data setup completed successfully.', 's');
        return true;
    }
    
    function validateProductionSecurity() {
        const warnings = [];
        collectionsDefinition.forEach(collection => {
            const collName = collection.name === "users" ? "_pb_users_auth_" : collection.name;
            if ((collection.createRule === "" || collection.createRule === "@everyone") && collName !== "orders" && collName !== "_pb_users_auth_") {
                warnings.push(`Collection "${collName}" has public createRule.`);
            }
           
            if (collection.type === "auth" && (collection.name === "users" || collection.name === "_pb_users_auth_")) {
                 const authOptions = collection.options || {};
                if (authOptions.requireEmailVerification === false) {
                    warnings.push(`Auth Collection "${collName}" has 'requireEmailVerification' set to false. Recommended to enable for production.`);
                }
            }
        });
        
        if (ADM_E === 'admin@example.com' && ADM_P === 'unifiedpassword') {
            warnings.push('Using default admin credentials (admin@example.com / unifiedpassword) - CHANGE FOR PRODUCTION!');
        }
        
        if (warnings.length > 0) {
            log('🚨 PRODUCTION SECURITY WARNINGS:', 'e');
            warnings.forEach(warning => log(`⚠️  ${warning}`, 'w'));
            log('🚨 REVIEW AND SECURE THESE BEFORE PRODUCTION DEPLOYMENT', 'e');
        } else {
            log('✓ Production security preliminary checks passed (always review rules manually for production).', 's');
        }
        return warnings.length === 0;
    }

    runFullSetupButton.onclick = async () => {
        [runFullSetupButton, runSchemaOnlyButton, runSeedOnlyButton].forEach(b => b.disabled = true);
        outputDiv.innerHTML = ''; 
        log('=== FULL SETUP PROCESS STARTED ===', 'i');
        const pb = new PocketBase(pbUrl);
        let schemaSuccess = false;
        
        try {
            const schemaResult = await safeExecute(async (pbInstance) => setupSchema(pbInstance), "Schema Setup", pb);
            schemaSuccess = schemaResult.success;

            if (!schemaSuccess) {
                log('Schema setup failed, aborting full setup', 'e');
            } else {
                const seedResult = await safeExecute(async (pbInstance) => setupSeedData(pbInstance), "Seed Data", pb);
                if (!seedResult.success) {
                    log('Seed data setup failed, but schema might be okay.', 'w');
                }
                log('=== FULL SETUP COMPLETED ===', seedResult.success ? 's' : 'w');
                validateProductionSecurity();
            }
        } catch (error) {
            log(`CRITICAL UNHANDLED ERROR during full setup: ${error.message}`, 'e');
            console.error('Full setup unhandled error:', error);
        } finally {
            if (pb.authStore.isValid && pb.authStore.isAdmin) pb.authStore.clear();
            [runFullSetupButton, runSchemaOnlyButton].forEach(b => b.disabled = false);
             runSeedOnlyButton.disabled = !schemaSuccess; 
            log('Process finished, admin auth cleared if used.', 'i');
        }
    };

    runSchemaOnlyButton.onclick = async () => {
        [runFullSetupButton, runSchemaOnlyButton, runSeedOnlyButton].forEach(b => b.disabled = true);
        outputDiv.innerHTML = ''; 
        log('=== SCHEMA ONLY SETUP STARTED ===', 'i');
        const pb = new PocketBase(pbUrl);
        let success = false;
        
        try {
            const schemaResult = await safeExecute(async (pbInstance) => setupSchema(pbInstance), "Schema Setup", pb);
            success = schemaResult.success;
            if (success) {
                log('Schema setup completed successfully', 's');
                validateProductionSecurity();
            } else {
                 log('Schema setup FAILED', 'e');
            }
        } catch (error) {
            log(`UNHANDLED ERROR during schema setup: ${error.message}`, 'e');
            console.error('Schema error:', error);
        } finally {
            if (pb.authStore.isValid && pb.authStore.isAdmin) pb.authStore.clear();
            [runFullSetupButton, runSchemaOnlyButton].forEach(b => b.disabled = false);
            runSeedOnlyButton.disabled = !success;
            log('Schema only process finished, admin auth cleared if used.', 'i');
        }
    };

    runSeedOnlyButton.onclick = async () => {
        [runFullSetupButton, runSchemaOnlyButton, runSeedOnlyButton].forEach(b => b.disabled = true);
        outputDiv.innerHTML = ''; 
        log('=== SEED DATA ONLY STARTED ===', 'i');
        const pb = new PocketBase(pbUrl);
        let success = false;
        
        try {
            const seedResult = await safeExecute(async (pbInstance) => setupSeedData(pbInstance), "Seed Data", pb);
            success = seedResult.success;
             if (success) {
                log('Seed data setup completed successfully', 's');
            } else {
                 log('Seed data setup FAILED or completed with errors.', 'w');
            }
        } catch (error) {
            log(`UNHANDLED ERROR during seed setup: ${error.message}`, 'e');
            console.error('Seed error:', error);
        } finally {
            if (pb.authStore.isValid && pb.authStore.isAdmin) pb.authStore.clear();
            [runFullSetupButton, runSchemaOnlyButton, runSeedOnlyButton].forEach(b => b.disabled = false);
            log('Seed data only process finished, admin auth cleared if used.', 'i');
        }
    };
</script>
</body>
</html>