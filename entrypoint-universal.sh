#!/bin/bash
# Universal PocketBase AutoDeploy - Static Site Generator Edition
set -euo pipefail

# Configuration
REPO="${REPO:-/srv/repo}"; APP_ROOT="${PB_APP_ROOT:-/srv/pb}"; DATA_DIR="${DATA_DIR:-$APP_ROOT/pb_runtime}"; BACKUPS_DIR="${BACKUPS_DIR:-$APP_ROOT/backups}"; PB_BIN="${PB_BINARY_PATH:-$APP_ROOT/bin/pb}"; INTERVAL="${PULL_INTERVAL:-60}"; TIMEOUT="${TIMEOUT:-120}"; PB_VERSION="${PB_VERSION:-latest}"; PB_PORT="${PB_PORT:-8090}"; REPO_URL="${REPO_URL:-}"; GIT_TOKEN="${GIT_TOKEN:-}"; GIT_BRANCH="${GIT_BRANCH:-main}"; ADMIN_EMAIL="${ADMIN_EMAIL:-}"; ADMIN_PASS="${ADMIN_PASS:-}"; BACKUP_ENABLED="${BACKUP_ENABLED:-false}"; BACKUP_DAYS="${BACKUP_DAYS:-7}"; MAX_BACKUPS="${MAX_BACKUPS:-30}"; DEBUG="${DEBUG:-false}"; FIRST_RUN="true"; FRONTEND_DIR="${FRONTEND_DIR:-frontend}"; BACKEND_DIR="${BACKEND_DIR:-backend}"

# Basic functions
log() { echo "[$(date +'%H:%M:%S')] $1"; }; exists() { command -v "$1" >/dev/null 2>&1; }; is_running() { pgrep -f "$PB_BIN.*serve" >/dev/null 2>&1; }; cleanup() { log "üßπ Cleaning up processes..." && pkill -f "$PB_BIN.*serve" 2>/dev/null || true; }

# Setup functions with error capture
setup_dirs() { log "üìÅ Creating directories..." && { mkdir -p "$(dirname "$PB_BIN")" "$DATA_DIR/pb_data" "$BACKUPS_DIR" "$REPO" 2>&1 | tee /tmp/dirs.log >/dev/null && log "‚úÖ Directories ready"; } || { log "‚ùå Directory creation failed:" && tail -5 /tmp/dirs.log; }; }; install_deps() { log "üì¶ Checking dependencies..." && exists git && exists pnpm && log "‚úÖ Dependencies ready" && return 0; log "üì• Installing dependencies..." && { grep -q "edge/community" /etc/apk/repositories 2>/dev/null || echo "http://dl-cdn.alpinelinux.org/alpine/edge/community" >> /etc/apk/repositories; } && { apk add --no-cache git wget unzip jq nodejs npm coreutils file 2>&1 | tee /tmp/deps.log | grep -E "(Installing|OK:|ERROR:|WARNING:)" || true; } && { exists pnpm || { npm install -g pnpm 2>&1 | tee /tmp/pnpm.log | grep -E "(added|ERROR:|npm ERR!)" || true; }; } && log "‚úÖ Dependencies installed" || { log "‚ùå Dependency installation failed:" && grep -E "(ERROR:|npm ERR!|FAIL)" /tmp/deps.log /tmp/pnpm.log 2>/dev/null | head -10; }; }; get_pb() { log "üîç Checking PocketBase..." && test -x "$PB_BIN" && "$PB_BIN" --help >/dev/null 2>&1 && log "‚úÖ PocketBase ready" && return 0; log "üì• Installing PocketBase..." && local ver="$PB_VERSION"; test "$PB_VERSION" = "latest" && { ver=$(wget -qO- https://api.github.com/repos/pocketbase/pocketbase/releases/latest 2>&1 | tee /tmp/pb_ver.log | jq -r '.tag_name' 2>/dev/null | sed 's/^v//') || { log "‚ö†Ô∏è Failed to get latest version:" && head -5 /tmp/pb_ver.log && ver="0.28.4"; }; } || ver="${PB_VERSION#v}"; test -z "$ver" && ver="0.28.4"; log "üì¶ Downloading PocketBase v$ver..." && { wget -O /tmp/pb.zip "https://github.com/pocketbase/pocketbase/releases/download/v${ver}/pocketbase_${ver}_linux_amd64.zip" 2>&1 | tee /tmp/pb_dl.log | grep -E "(Saving|ERROR:|failed)" || true; } && { test -f /tmp/pb.zip && unzip -t /tmp/pb.zip >/dev/null 2>&1 && mkdir -p "$(dirname "$PB_BIN")" && unzip -p /tmp/pb.zip pocketbase > "$PB_BIN" && rm -f /tmp/pb.zip && chmod 755 "$PB_BIN" && test -x "$PB_BIN" && "$PB_BIN" version >/dev/null 2>&1 && log "‚úÖ PocketBase v$ver ready"; } || { log "‚ùå PocketBase installation failed:" && tail -10 /tmp/pb_dl.log 2>/dev/null; }; }; setup_admin() { log "üë§ Setting up admin..." && test -n "$ADMIN_EMAIL" && test -n "$ADMIN_PASS" && test "$FIRST_RUN" = "true" && { local admin_output=$("$PB_BIN" superuser upsert --dir="$DATA_DIR" "$ADMIN_EMAIL" "$ADMIN_PASS" 2>&1) && log "‚úÖ Admin ready" || { log "‚ö†Ô∏è Admin setup issue:" && echo "$admin_output" | grep -E "(error|failed|Error)" | head -5; }; } || log "‚ÑπÔ∏è Admin setup skipped"; }

# Git functions with error capture
auth_url() { test -n "$GIT_TOKEN" && echo "$1" | grep -q -E "(github|gitlab|bitbucket)" && echo "${1/https:\/\//https://oauth2:${GIT_TOKEN}@}" || echo "$1"; }; clone_repo() { log "üì• Setting up repository..." && test -d "$REPO/.git" && { cd "$REPO" && git fetch origin "$GIT_BRANCH" --quiet 2>&1 && log "‚úÖ Repository ready" && return 0 || { log "‚ö†Ô∏è Repo corrupted, re-cloning..." && cd / && rm -rf "$REPO"; }; }; test -z "$REPO_URL" && log "‚ö†Ô∏è No repository configured" && return 0; local retries=3; while [ "$retries" -gt 0 ]; do { git ls-remote --heads "$(auth_url "$REPO_URL")" "$GIT_BRANCH" 2>&1 | tee /tmp/git_check.log >/dev/null && break; } || { log "‚ö†Ô∏è Connection attempt $((4-retries))/3 failed:" && grep -E "(fatal|error|Failed)" /tmp/git_check.log | head -2 && retries=$((retries-1)) && sleep 5; }; done; test "$retries" -eq 0 && { log "‚ùå Repository unreachable, continuing without it" && return 0; }; rm -rf "$REPO" 2>/dev/null && mkdir -p "$REPO" && { git clone --depth 1 -b "$GIT_BRANCH" "$(auth_url "$REPO_URL")" "$REPO" 2>&1 | tee /tmp/git_clone.log | grep -E "(Cloning|Receiving|Resolving|done|error|fatal)" || true; } && log "‚úÖ Repository ready ($(find "$REPO" -name "*.js" -o -name "*.html" 2>/dev/null | wc -l) files)" || { log "‚ùå Clone failed:" && tail -10 /tmp/git_clone.log; }; }; check_updates() { test -d "$REPO/.git" || return 1; cd "$REPO" 2>/dev/null || return 1; { git fetch origin "$GIT_BRANCH" --quiet 2>&1 | tee /tmp/git_fetch.log >/dev/null || { grep -q "fatal" /tmp/git_fetch.log && log "‚ö†Ô∏è Fetch error" && return 1; }; }; local local_hash=$(git rev-parse HEAD 2>/dev/null || echo "none") && local remote_hash=$(git rev-parse "origin/$GIT_BRANCH" 2>/dev/null || echo "none") && test "$local_hash" != "$remote_hash" && test "$local_hash" != "none" && test "$remote_hash" != "none"; }; apply_updates() { log "üì• Applying updates..." && cd "$REPO" && { git reset --hard "origin/$GIT_BRANCH" 2>&1 | tee /tmp/git_reset.log | grep -E "(HEAD is now|error|fatal)" || true; } && log "‚úÖ Updates applied" || { log "‚ö†Ô∏è Update failed:" && tail -5 /tmp/git_reset.log; }; }

# Universal framework detection and build functions
detect_framework() { local check_dir="$REPO"; test -d "$REPO/$FRONTEND_DIR" && check_dir="$REPO/$FRONTEND_DIR"; test -f "$check_dir/svelte.config.js" && echo "svelte" && return; test -f "$check_dir/nuxt.config.js" -o -f "$check_dir/nuxt.config.ts" && echo "nuxt" && return; test -f "$check_dir/next.config.js" -o -f "$check_dir/next.config.ts" && echo "nextjs" && return; test -f "$check_dir/vite.config.js" -o -f "$check_dir/vite.config.ts" && echo "vite" && return; test -f "$check_dir/vue.config.js" && echo "vue" && return; test -f "$check_dir/angular.json" && echo "angular" && return; test -f "$check_dir/gatsby-config.js" && echo "gatsby" && return; test -f "$check_dir/remix.config.js" && echo "remix" && return; test -f "$check_dir/astro.config.mjs" -o -f "$check_dir/astro.config.js" && echo "astro" && return; test -f "$check_dir/solid.config.js" && echo "solid" && return; test -f "$check_dir/package.json" && echo "generic" && return; test -f "$check_dir/index.html" -o -f "$check_dir/index.htm" && echo "static-html" && return; test -d "$check_dir/vendor" -o -d "$check_dir/assets" -o -d "$check_dir/css" -o -d "$check_dir/js" && echo "static-assets" && return; echo "static"; }; detect_output_dir() { local framework="$1" && local base_dir="$2"; case "$framework" in svelte) for d in build dist public; do test -d "$base_dir/$d" && echo "$base_dir/$d" && return; done; echo "$base_dir/build" ;; nuxt) for d in .output/public dist .nuxt/dist; do test -d "$base_dir/$d" && echo "$base_dir/$d" && return; done; echo "$base_dir/.output/public" ;; nextjs) for d in out .next/static .next; do test -d "$base_dir/$d" && echo "$base_dir/$d" && return; done; echo "$base_dir/out" ;; vite) for d in dist build; do test -d "$base_dir/$d" && echo "$base_dir/$d" && return; done; echo "$base_dir/dist" ;; vue) for d in dist build; do test -d "$base_dir/$d" && echo "$base_dir/$d" && return; done; echo "$base_dir/dist" ;; angular) for d in dist/*/; do test -d "$d" && echo "$d" && return; done; echo "$base_dir/dist" ;; gatsby) for d in public build; do test -d "$base_dir/$d" && echo "$base_dir/$d" && return; done; echo "$base_dir/public" ;; remix) for d in build/client public/build; do test -d "$base_dir/$d" && echo "$base_dir/$d" && return; done; echo "$base_dir/build/client" ;; astro) for d in dist build; do test -d "$base_dir/$d" && echo "$base_dir/$d" && return; done; echo "$base_dir/dist" ;; solid) for d in dist build; do test -d "$base_dir/$d" && echo "$base_dir/$d" && return; done; echo "$base_dir/dist" ;; static-html|static-assets) echo "$base_dir" ;; generic) for d in dist build out public www htdocs web assets static; do test -d "$base_dir/$d" && echo "$base_dir/$d" && return; done; test -f "$base_dir/index.html" && echo "$base_dir" || echo "$base_dir/dist" ;; *) echo "$base_dir" ;; esac; }; detect_dir() { local check_dir="$REPO"; test -d "$REPO/$FRONTEND_DIR" && check_dir="$REPO/$FRONTEND_DIR"; local framework=$(detect_framework); local output_dir=$(detect_output_dir "$framework" "$check_dir"); test -d "$output_dir" && echo "$output_dir" || echo "$check_dir"; }; get_package_manager() { local check_dir="$REPO"; test -d "$REPO/$FRONTEND_DIR" && check_dir="$REPO/$FRONTEND_DIR"; test -f "$check_dir/pnpm-lock.yaml" && echo "pnpm" && return; test -f "$check_dir/yarn.lock" && echo "yarn" && return; test -f "$check_dir/package-lock.json" && echo "npm" && return; test -f "$check_dir/bun.lockb" && echo "bun" && return; exists pnpm && echo "pnpm" && return; echo "npm"; }; get_build_command() { local framework=$(detect_framework); case "$framework" in svelte) echo "build" ;; nuxt) echo "generate" ;; nextjs) echo "build" ;; vite) echo "build" ;; vue) echo "build" ;; angular) echo "build --prod" ;; gatsby) echo "build" ;; remix) echo "build" ;; astro) echo "build" ;; solid) echo "build" ;; generic) echo "build" ;; *) echo "build" ;; esac; }; needs_build() { local framework=$(detect_framework); case "$framework" in static-html|static-assets|static) return 1 ;; esac; test -d "$REPO/$FRONTEND_DIR" && test -f "$REPO/$FRONTEND_DIR/package.json" || return 1; local build_dir=$(detect_dir); test "$build_dir" = "$REPO/$FRONTEND_DIR" && return 0; test ! -d "$build_dir" && return 0; test "$REPO/$FRONTEND_DIR/package.json" -nt "$build_dir" && return 0; return 1; }; build_app() { needs_build || return 0; local framework=$(detect_framework); log "üî® Building $framework application..." && test -d "$REPO/$FRONTEND_DIR" || { log "‚ÑπÔ∏è No frontend directory found"; return 0; }; cd "$REPO/$FRONTEND_DIR" 2>/dev/null || return 0; local pm=$(get_package_manager); exists "$pm" || { log "‚ùå Package manager '$pm' not available" && return 0; }; local timeout_cmd=""; exists timeout && timeout_cmd="timeout 600"; log "üì¶ Installing dependencies with $pm..." && { $timeout_cmd $pm install 2>&1 | tee /tmp/npm_install.log | grep -E "(added|updated|resolved|warn|error|ERR!)" | tail -20 || true; } || { log "‚ùå Dependency installation failed:" && grep -E "(error|ERR!)" /tmp/npm_install.log | head -10; return 0; }; local build_cmd=$(get_build_command); test -f "package.json" && grep -q '"build"' "package.json" && { log "üèóÔ∏è Running $framework build ($build_cmd)..." && { $timeout_cmd $pm run $build_cmd 2>&1 | tee /tmp/build.log | grep -E "(Building|Compiling|Creating|Generated|‚úì|‚úî|Error|Failed)" | tail -20 || true; } && log "‚úÖ $framework build complete" || { log "‚ùå Build failed:" && grep -E "(Error|ERROR|Failed|FAILED)" /tmp/build.log | head -10 || tail -20 /tmp/build.log; }; } || log "‚ÑπÔ∏è No build script for $framework"; cd "$APP_ROOT" 2>/dev/null || true; }

# Enhanced static serving configuration
configure_static_serving() { local public_dir=$(detect_dir); test -d "$public_dir" && { log "üîß Configuring static file serving..." && { test -f /etc/mime.types && test -s /etc/mime.types || cat > /etc/mime.types << 'EOF'
application/javascript                  js mjs
text/css                                css
application/json                        json
text/html                               html htm
text/plain                              txt
image/png                               png
image/jpeg                              jpg jpeg
image/gif                               gif
image/svg+xml                           svg
application/pdf                         pdf
application/wasm                        wasm
font/woff                               woff
font/woff2                              woff2
font/ttf                                ttf
font/otf                                otf
EOF
} && find "$public_dir" -type f -name "*.js" -o -name "*.css" -o -name "*.json" -exec chmod 644 {} + 2>/dev/null && find "$public_dir" -type d -exec chmod 755 {} + 2>/dev/null && { test -f "$public_dir/alpine.min.js" && log "üìÑ Alpine.js found in root"; } && { test -f "$public_dir/pocketbase.umd.js" && log "üìÑ PocketBase SDK found in root"; } && { test -f "$public_dir/alpine-collapse.min.js" && log "üìÑ Alpine Collapse found in root"; } && log "‚úÖ Static serving configured"; }; }; validate_static_serving() { local public_dir=$(detect_dir) && local port=${PB_PORT:-8090} && command -v curl >/dev/null 2>&1 && is_running && { log "üß™ Validating static file serving..." && local js_file=$(find "$public_dir" -maxdepth 1 -name "alpine.min.js" -type f 2>/dev/null | head -1) && test -n "$js_file" && { local response=$(curl -s -I "http://localhost:$port/${js_file#$public_dir/}" 2>/dev/null | grep -i content-type || echo "no-response") && echo "$response" | grep -q "application/javascript\\|text/javascript" && log "‚úÖ Static serving validated" || log "‚ö†Ô∏è JavaScript MIME issue: ${js_file#$public_dir/} -> $response"; } || log "‚ÑπÔ∏è No JS files to validate"; } || { log "‚ÑπÔ∏è Static validation skipped"; return 0; }; }

# Enhanced server functions with monorepo support
stop_server() { is_running && { pkill -TERM -f "$PB_BIN.*serve" 2>/dev/null; sleep 2; pkill -KILL -f "$PB_BIN.*serve" 2>/dev/null || true; }; }; start_server() { stop_server; log "üöÄ Starting server..." && local hooks_dir="$REPO/$BACKEND_DIR/pb_hooks" && local migrations_dir="$REPO/$BACKEND_DIR/pb_migrations" && local public_dir=$(detect_dir) && configure_static_serving && test -d "$hooks_dir" && { log "üé£ Hooks: $(find "$hooks_dir" -name "*.js" 2>/dev/null | wc -l) files" && find "$hooks_dir" -name "*.js" -exec sh -c 'echo "  üìÑ $(basename "$1")"' _ {} + 2>/dev/null; } || log "‚ÑπÔ∏è No hooks"; test -d "$migrations_dir" && test "$(find "$migrations_dir" -name "*.js" 2>/dev/null | wc -l)" -gt 0 && { log "üóÑÔ∏è Running migrations from $migrations_dir..." && log "üìÑ Found $(find "$migrations_dir" -name "*.js" 2>/dev/null | wc -l) migration files" && { local mig_output=$("$PB_BIN" migrate up --dir="$DATA_DIR" --migrationsDir="$migrations_dir" 2>&1) && { echo "$mig_output" | grep -E "(Applying|Applied|up|migrated)" && log "‚úÖ Migrations applied successfully"; } || { log "‚ùå Migration failed - Full output:" && echo "$mig_output" && log "--- End migration output ---"; }; }; } || log "‚ÑπÔ∏è No migrations found in $migrations_dir"; log "üìÅ Serving static files from: $public_dir" && log "üîÑ Starting PocketBase with enhanced static serving..." && { "$PB_BIN" serve --http="0.0.0.0:$PB_PORT" --dir="$DATA_DIR" --publicDir="$public_dir" --hooksDir="$hooks_dir" --migrationsDir="$migrations_dir" > /tmp/pb_start.log 2>&1 & local pb_pid=$!; echo "$pb_pid" > /tmp/pb.pid; sleep 5; } && local real_pid=$(pgrep -f "$PB_BIN.*serve") && test -n "$real_pid" && { log "‚úÖ Server running on port $PB_PORT (PID: $real_pid)" && log "üìÇ Structure: Backend=/$BACKEND_DIR, Frontend=/$FRONTEND_DIR" && sleep 2 && validate_static_serving && return 0; } || { log "‚ùå Server failed to start" && log "üìã Error output:" && cat /tmp/pb_start.log 2>/dev/null | grep -E "(error|Error|panic|failed|Fatal|ReferenceError|SyntaxError|TypeError)" | grep -v "http server started" | head -20 && log "üîç Checking for common issues..." && { netstat -tlnp 2>/dev/null | grep ":$PB_PORT" && log "‚ö†Ô∏è Port $PB_PORT already in use!" || log "‚úÖ Port $PB_PORT is free"; } && { test -d "$hooks_dir" && grep -l "registerHook\|\$app" "$hooks_dir"/*.js 2>/dev/null && log "‚ö†Ô∏è Hooks using outdated API - should use onRecordBeforeCreateRequest, etc." || true; }; return 1; }; }

# Backup with error capture
create_backup() { test "$BACKUP_ENABLED" = "true" && test "$FIRST_RUN" != "true" && { local ts=$(date +%Y%m%d_%H%M%S); { cd "$(dirname "$REPO")" 2>/dev/null && tar -czf "$BACKUPS_DIR/repo_$ts.tar.gz" "$(basename "$REPO")" 2>&1 | tee /tmp/backup.log >/dev/null || { log "‚ö†Ô∏è Repo backup failed:" && tail -5 /tmp/backup.log; }; } || true; { cd "$(dirname "$DATA_DIR")" 2>/dev/null && tar -czf "$BACKUPS_DIR/data_$ts.tar.gz" "$(basename "$DATA_DIR")" 2>&1 | tee /tmp/backup_data.log >/dev/null && log "üíæ Backup saved" || { log "‚ö†Ô∏è Data backup failed:" && tail -5 /tmp/backup_data.log; }; } || true; } || true; }; cleanup_backups() { test "$BACKUP_ENABLED" = "true" && { find "$BACKUPS_DIR" -name "*.tar.gz" -mtime "+$BACKUP_DAYS" -delete 2>/dev/null || true; ls -t "$BACKUPS_DIR"/*.tar.gz 2>/dev/null | tail -n "+$((MAX_BACKUPS+1))" | xargs rm -f 2>/dev/null || true; } || true; }

# Main functions with error capture
run_setup() { log "üöÄ Initial setup..." && setup_dirs && install_deps && get_pb && clone_repo && setup_admin && build_app && configure_static_serving && start_server && log "‚úÖ Setup complete" || log "‚ö†Ô∏è Partial setup - check errors above"; }; run_update() { is_running || { log "‚ö†Ô∏è Server not running, attempting restart..." && start_server; }; check_updates && { create_backup; apply_updates && build_app && start_server; } || true; cleanup_backups; }; health_check() { is_running || { log "‚ôªÔ∏è Auto-recovering server..." && start_server; }; }

# Diagnostics function with monorepo info
diag() { log "üîç System diagnostics:" && log "üìÅ Working dirs:" && ls -la "$APP_ROOT" "$DATA_DIR" "$REPO" 2>/dev/null | grep -E "^d|^-.*pb" | head -10 && log "üìÇ Monorepo structure:" && { test -d "$REPO/$FRONTEND_DIR" && log "  ‚úÖ Frontend: $REPO/$FRONTEND_DIR" || log "  ‚ùå Frontend directory not found"; } && { test -d "$REPO/$BACKEND_DIR" && log "  ‚úÖ Backend: $REPO/$BACKEND_DIR" || log "  ‚ùå Backend directory not found"; } && { test -d "$REPO/$BACKEND_DIR/pb_hooks" && log "  ‚úÖ Hooks: $(find "$REPO/$BACKEND_DIR/pb_hooks" -name "*.js" 2>/dev/null | wc -l) files" || true; } && { test -d "$REPO/$BACKEND_DIR/pb_migrations" && log "  ‚úÖ Migrations: $(find "$REPO/$BACKEND_DIR/pb_migrations" -name "*.js" 2>/dev/null | wc -l) files" || true; } && log "üî® PocketBase:" && { "$PB_BIN" version 2>&1 || log "‚ùå Binary not working"; } && log "üåê Network:" && { netstat -tlnp 2>/dev/null | grep -E ":$PB_PORT|:80|:443" || log "‚ÑπÔ∏è No network info"; } && log "üìä Resources:" && df -h "$APP_ROOT" && { free -h 2>/dev/null || true; }; }

# Signal handling
trap 'log "üëã Shutting down..." && cleanup && exit 0' SIGINT SIGTERM

# Main execution
log "ü§ñ Universal PocketBase AutoDeploy - Static Site Generator Edition"; log "üìç Repository: ${REPO_URL:-local} | Branch: $GIT_BRANCH | Port: $PB_PORT"; log "üìÇ Structure: Backend=/$BACKEND_DIR Frontend=/$FRONTEND_DIR"

# Single run or continuous mode
test "$INTERVAL" -eq 0 && { run_setup; exit 0; } || { run_setup; FIRST_RUN="false"; log "‚ôæÔ∏è Entering autonomous monitoring mode..."; HEALTH_CHECK_COUNTER=0; while true; do HEALTH_CHECK_COUNTER=$((HEALTH_CHECK_COUNTER + 1)); test "$HEALTH_CHECK_COUNTER" -ge 5 && { health_check; HEALTH_CHECK_COUNTER=0; }; run_update; sleep "$INTERVAL"; done; }