<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PB Setup: SheepLand Udheya</title>
    <script src="https://unpkg.com/pocketbase@latest/dist/pocketbase.umd.js"></script>
    <style>
        body{font-family:sans-serif;font-size:13px;line-height:1.4;padding:10px;background:#f0f0f0;color:#333;display:flex;flex-direction:column;align-items:center;margin:0;}
        .c{max-width:700px;width:100%;background:white;padding:15px;border-radius:5px;box-shadow:0 2px 8px rgba(0,0,0,0.1);}
        h1{color:#333;border-bottom:1px solid #ccc;padding-bottom:5px;margin:0 0 10px 0;font-size:1.2em;}
        p{font-size:0.9em;margin:0 0 0.5em 0;} .warn{color:red;font-weight:bold;}
        button{padding:6px 10px;background:#007bff;color:white;border:0;border-radius:3px;cursor:pointer;font-size:0.85em;margin-bottom:5px;}
        button:disabled{background:#ccc;} button:hover:not(:disabled){background:#0056b3;}
        #out{margin-top:10px;padding:8px;background:#222;color:#eee;border-radius:3px;white-space:pre-wrap;font-family:monospace;font-size:11px;max-height:70vh;overflow-y:auto;}
        .ls{color:lime;font-weight:bold;} .le{color:salmon;font-weight:bold;} .li{color:cyan;} .lw{color:yellow;} .ld{color:gray;}
    </style>
</head>
<body>
    <div class="c">
        <h1>PB SheepLand Udheya Setup</h1>
        <p class="warn">WARNING: This script uses default admin credentials (admin@example.com / unifiedpassword). CHANGE THESE IMMEDIATELY in a production environment. This script will create/update collections and data. Backup your existing data if necessary.</p>
        <button id="runFullSetup">Run Full Setup</button>
        <button id="runSchemaOnly">Schema Only</button>
        <button id="runSeedOnly" disabled>Seed Data Only</button>
        <div id="out"></div>
    </div>
<script>
    const pbUrl = '/';
    const outputDiv = document.getElementById('out');
    const runFullSetupButton = document.getElementById('runFullSetup');
    const runSchemaOnlyButton = document.getElementById('runSchemaOnly');
    const runSeedOnlyButton = document.getElementById('runSeedOnly');
    const ADM_E = 'admin@example.com';
    const ADM_P = 'unifiedpassword';

    const log = (message, type = 'i', data = null) => {
        const timestamp = `[${new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' })}] `;
        const p = document.createElement('p');
        p.className = `l${type[0]}`;
        let logMessage = timestamp + message.replace(/</g, '<').replace(/>/g, '>');
        if (data) {
            logMessage += `\n<pre class="ld">${JSON.stringify(data, null, 2).replace(/</g, '<').replace(/>/g, '>')}</pre>`;
        }
        p.innerHTML = logMessage;
        outputDiv.appendChild(p);
        outputDiv.scrollTop = outputDiv.scrollHeight;
        const consoleMessage = timestamp + message.replace(/<[^>]*>?/gm, '');
        if (type === 'e') console.error(consoleMessage, data || '');
        else if (type === 'w') console.warn(consoleMessage, data || '');
        else if (type === 'd') console.debug(consoleMessage, data || '');
        else console.log(consoleMessage, data || '');
    };

    const collectionsWithoutRelations = [
        {
            name: "settings",
            type: "base",
            listRule: "", viewRule: "", createRule: null, updateRule: null, deleteRule: null,
            // Schema items: 'fields' is the correct key for the pb.collections.import()
            // Field-specific options (like max, min, pattern) are direct properties of the field object.
            fields: [
                { name: "xchgRates", type: "json", required: true, presentable: true },
                { name: "defCurr", type: "text", required: true, presentable: true, max: 5 }, // Max is direct
                { name: "waNumRaw", type: "text", required: false, presentable: true },
                { name: "waNumDisp", type: "text", required: false, presentable: true },
                { name: "promoEndISO", type: "date", required: false, presentable: true },
                { name: "promoDiscPc", type: "number", required: false, presentable: true, min: 0, max: 100 }, // min, max direct
                { name: "promoActive", type: "bool", required: false, presentable: true },
                { name: "servFeeEGP", type: "number", required: true, presentable: true, min: 0 }, // min direct
                { name: "delAreas", type: "json", required: false, presentable: true },
                { name: "payDetails", type: "json", required: false, presentable: true }
            ],
            options: { // Collection-level options
                maxRecords: 1
            }
        },
        {
            name: "products",
            type: "base",
            listRule: "", viewRule: "", createRule: "", updateRule: "", deleteRule: "",
            fields: [
                { name: "item_key", type: "text", required: true, presentable: true, unique: true, max: 100, pattern: "^[a-z0-9_]+$" },
                { name: "type_key", type: "text", required: true, presentable: true, max: 50, pattern: "^[a-z0-9_]+$" },
                { name: "type_name_en", type: "text", required: true, presentable: true, max: 100 },
                { name: "type_name_ar", type: "text", required: true, presentable: true, max: 100 },
                { name: "type_description_en", type: "text", required: false, presentable: true, max: 200 },
                { name: "type_description_ar", type: "text", required: false, presentable: true, max: 200 },
                { name: "price_per_kg_egp", type: "number", required: true, presentable: true, min: 0 },
                { name: "variant_name_en", type: "text", required: true, presentable: true, max: 150 },
                { name: "variant_name_ar", type: "text", required: true, presentable: true, max: 150 },
                { name: "weight_range_text_en", type: "text", required: true, presentable: true, max: 50 },
                { name: "weight_range_text_ar", type: "text", required: true, presentable: true, max: 50 },
                { name: "avg_weight_kg", type: "number", required: true, presentable: true, min: 0 },
                { name: "base_price_egp", type: "number", required: true, presentable: true, min: 0, noDecimal: false },
                { name: "stock_available_pb", type: "number", required: true, presentable: true, min: 0, noDecimal: true },
                { name: "is_active", type: "bool", required: false, presentable: true },
                { name: "sort_order_type", type: "number", required: false, presentable: true, min: 0, noDecimal: true },
                { name: "sort_order_variant", type: "number", required: false, presentable: true, min: 0, noDecimal: true }
            ]
        },
        {
            name: "bookings",
            type: "base",
            // Temporarily simplify rules for initial import
            listRule: "", // Public for now, will be tightened
            viewRule: "", // Public for now
            createRule: "", // Public for now
            updateRule: null, // Admin only for now
            deleteRule: null, // Admin only for now
            fields: [
                { name: "booking_id_text", type: "text", required: true, presentable: true, unique: true, max: 50 },
                { name: "booked_product_name_en", type: "text", required: false, presentable: true, max: 150 },
                { name: "booked_product_name_ar", type: "text", required: false, presentable: true, max: 150 },
                { name: "booked_weight_range_en", type: "text", required: false, presentable: true, max: 50 },
                { name: "booked_weight_range_ar", type: "text", required: false, presentable: true, max: 50 },
                { name: "booked_price_at_booking_egp", type: "number", required: true, presentable: true, min: 0, noDecimal: false },
                { name: "udheya_service_option_selected", type: "text", required: true, presentable: true, max: 50 },
                { name: "service_fee_applied_egp", type: "number", required: true, presentable: true, min: 0, noDecimal: false },
                { name: "delivery_fee_applied_egp", type: "number", required: false, presentable: true, min: 0, noDecimal: false },
                { name: "total_amount_due_egp", type: "number", required: true, presentable: true, min: 0, noDecimal: false },
                { name: "selected_display_currency", type: "text", required: false, presentable: true, max: 5 },
                { name: "sacrifice_day_value", type: "text", required: true, presentable: true, max: 50 },
                { name: "sacrifice_day_text_en", type: "text", required: false, presentable: true, max: 100 },
                { name: "sacrifice_day_text_ar", type: "text", required: false, presentable: true, max: 100 },
                { name: "slaughter_viewing_preference", type: "text", required: false, presentable: true, max: 50 },
                { name: "distribution_choice", type: "text", required: false, presentable: true, max: 50 },
                { name: "split_details_option", type: "text", required: false, presentable: true, max: 100 },
                { name: "custom_split_details_text", type: "text", required: false, presentable: true, max: 500 },
                { name: "niyyah_names", type: "text", required: false, presentable: true, max: 500 },
                { name: "ordering_person_name", type: "text", required: true, presentable: true, max: 150 },
                { name: "ordering_person_phone", type: "text", required: true, presentable: true, max: 30 },
                { name: "customer_email", type: "email", required: false, presentable: true },
                { name: "delivery_option", type: "text", required: false, presentable: true, max: 50 },
                { name: "delivery_name", type: "text", required: false, presentable: true, max: 150 },
                { name: "delivery_phone", type: "text", required: false, presentable: true, max: 30 },
                { name: "delivery_area_id", type: "text", required: false, presentable: true, max: 50 },
                { name: "delivery_area_name_en", type: "text", required: false, presentable: true, max: 100 },
                { name: "delivery_area_name_ar", type: "text", required: false, presentable: true, max: 100 },
                { name: "delivery_address", type: "text", required: false, presentable: true, max: 500 },
                { name: "delivery_instructions", type: "text", required: false, presentable: true, max: 500 },
                { name: "time_slot", type: "text", required: false, presentable: true, max: 50 },
                { name: "payment_method", type: "text", required: true, presentable: true, max: 50 },
                { name: "payment_status", type: "select", required: true, presentable: true, maxSelect: 1, values: ["pending_payment", "payment_under_review", "paid_confirmed", "cod_pending_confirmation", "cod_confirmed_pending_delivery", "failed", "refunded"] }, // values direct
                { name: "booking_status", type: "select", required: true, presentable: true, maxSelect: 1, values: ["confirmed_pending_payment", "payment_confirmed_processing", "ready_for_fulfillment", "fulfilled_completed", "cancelled_by_user", "cancelled_by_admin"] }, // values direct
                { name: "terms_agreed", type: "bool", required: false, presentable: true },
                { name: "admin_notes", type: "text", required: false, presentable: true, max: 1000 },
                { name: "group_purchase_interest", type: "bool", required: false, presentable: true },
                { name: "user_ip_address", type: "text", required: false, presentable: true, max: 50 },
                { name: "user_agent_string", type: "text", required: false, presentable: true, max: 300 }
            ]
        }
    ];

    const seedData = {
        settings: [
            {
                xchgRates: { EGP: { rate_from_egp: 1, symbol: "LE", is_active: true }, USD: { rate_from_egp: 0.020, symbol: "$", is_active: true }, GBP: { rate_from_egp: 0.015, symbol: "Â£", is_active: true } },
                defCurr: "EGP",
                waNumRaw: "201117117489", waNumDisp: "+20 11 1711 7489",
                promoEndISO: new Date("2025-06-07T00:00:00.000Z").toISOString(),
                promoDiscPc: 10,
                promoActive: true,
                servFeeEGP: 750,
                delAreas: [
                    { id: "giza_west", name_en: "Giza West", name_ar: "ØºØ±Ø¨ Ø§Ù„Ø¬ÙŠØ²Ø©", cities: [ { id: "october", name_en: "6th of October City", name_ar: "Ù…Ø¯ÙŠÙ†Ø© 6 Ø£ÙƒØªÙˆØ¨Ø±", delivery_fee_egp: 150 }, { id: "zayed", name_en: "Sheikh Zayed", name_ar: "Ø§Ù„Ø´ÙŠØ® Ø²Ø§ÙŠØ¯", delivery_fee_egp: 150 }, { id: "euro_reef", name_en: "European Reef", name_ar: "Ø§Ù„Ø±ÙŠÙ Ø§Ù„Ø£ÙˆØ±ÙˆØ¨Ù‰", delivery_fee_egp: 150 } ] },
                    { id:"cairo", name_en:"Cairo", name_ar:"Ø§Ù„Ù‚Ø§Ù‡Ø±Ø©", cities:[ {id:"nasr_city", name_en:"Nasr City", name_ar:"Ù…Ø¯ÙŠÙ†Ø© Ù†ØµØ±", delivery_fee_egp: 250 }, {id:"maadi", name_en:"Maadi", name_ar:"Ø§Ù„Ù…Ø¹Ø§Ø¯ÙŠ", delivery_fee_egp: 250 }, {id:"heliopolis", name_en:"Heliopolis", name_ar:"Ù…ØµØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©", delivery_fee_egp: 250} ] }
                ],
                payDetails: { vodafone_cash: "01076543210", instapay_ipn: "seed_user@instapay", revolut_details: "@seedUserRevolut", monzo_details: "monzo.me/seeduser", bank_name: "Seed Bank Egypt", bank_account_name: "Sheep Land Seed Account", bank_account_number: "1234567890123456", bank_iban: "EG00123400000000001234567890", bank_swift: "SEEDBANKEGCA" }
            }
        ],
        products: [
            { item_key: "baladi_40_50", type_key: "baladi", type_name_en: "Baladi Sheep", type_name_ar: "Ø®Ø±ÙˆÙ Ø¨Ù„Ø¯ÙŠ", type_description_en: "Local breed, rich flavor.", type_description_ar: "Ø³Ù„Ø§Ù„Ø© Ù…Ø­Ù„ÙŠØ©ØŒ Ù†ÙƒÙ‡Ø© ØºÙ†ÙŠØ©.", price_per_kg_egp: 230, variant_name_en: "Baladi (40-50kg)", variant_name_ar: "Ø¨Ù„Ø¯ÙŠ (Ù¤Ù -Ù¥Ù ÙƒØ¬Ù…)", weight_range_text_en: "40-50kg", weight_range_text_ar: "Ù¤Ù -Ù¥Ù  ÙƒØ¬Ù…", avg_weight_kg: 45, base_price_egp: (45 * 230), stock_available_pb: 7, is_active: true, sort_order_type: 1, sort_order_variant: 1 },
            { item_key: "baladi_50_60", type_key: "baladi", type_name_en: "Baladi Sheep", type_name_ar: "Ø®Ø±ÙˆÙ Ø¨Ù„Ø¯ÙŠ", type_description_en: "Local breed, rich flavor.", type_description_ar: "Ø³Ù„Ø§Ù„Ø© Ù…Ø­Ù„ÙŠØ©ØŒ Ù†ÙƒÙ‡Ø© ØºÙ†ÙŠØ©.", price_per_kg_egp: 230, variant_name_en: "Baladi (50-60kg)", variant_name_ar: "Ø¨Ù„Ø¯ÙŠ (Ù¥Ù -Ù¦Ù ÙƒØ¬Ù…)", weight_range_text_en: "50-60kg", weight_range_text_ar: "Ù¥Ù -Ù¦Ù  ÙƒØ¬Ù…", avg_weight_kg: 55, base_price_egp: (55 * 230), stock_available_pb: 8, is_active: true, sort_order_type: 1, sort_order_variant: 2 },
            { item_key: "baladi_60_plus", type_key: "baladi", type_name_en: "Baladi Sheep", type_name_ar: "Ø®Ø±ÙˆÙ Ø¨Ù„Ø¯ÙŠ", type_description_en: "Local breed, rich flavor.", type_description_ar: "Ø³Ù„Ø§Ù„Ø© Ù…Ø­Ù„ÙŠØ©ØŒ Ù†ÙƒÙ‡Ø© ØºÙ†ÙŠØ©.", price_per_kg_egp: 230, variant_name_en: "Baladi (60+kg)", variant_name_ar: "Ø¨Ù„Ø¯ÙŠ (+Ù¦Ù ÙƒØ¬Ù…)", weight_range_text_en: "60+kg", weight_range_text_ar: "+Ù¦Ù  ÙƒØ¬Ù…", avg_weight_kg: 65, base_price_egp: (65 * 230), stock_available_pb: 1, is_active: true, sort_order_type: 1, sort_order_variant: 3 },
            { item_key: "barki_30_40", type_key: "barki", type_name_en: "Barki Sheep", type_name_ar: "Ø®Ø±ÙˆÙ Ø¨Ø±Ù‚ÙŠ", type_description_en: "Desert breed, lean meat.", type_description_ar: "Ø³Ù„Ø§Ù„Ø© ØµØ­Ø±Ø§ÙˆÙŠØ©ØŒ Ù„Ø­Ù… Ù‚Ù„ÙŠÙ„ Ø§Ù„Ø¯Ù‡Ù†.", price_per_kg_egp: 255, variant_name_en: "Barki (30-40kg)", variant_name_ar: "Ø¨Ø±Ù‚ÙŠ (Ù£Ù -Ù¤Ù ÙƒØ¬Ù…)", weight_range_text_en: "30-40kg", weight_range_text_ar: "Ù£Ù -Ù¤Ù  ÙƒØ¬Ù…", avg_weight_kg: 35, base_price_egp: (35 * 255), stock_available_pb: 1, is_active: true, sort_order_type: 2, sort_order_variant: 1 },
            { item_key: "barki_40_50", type_key: "barki", type_name_en: "Barki Sheep", type_name_ar: "Ø®Ø±ÙˆÙ Ø¨Ø±Ù‚ÙŠ", type_description_en: "Desert breed, lean meat.", type_description_ar: "Ø³Ù„Ø§Ù„Ø© ØµØ­Ø±Ø§ÙˆÙŠØ©ØŒ Ù„Ø­Ù… Ù‚Ù„ÙŠÙ„ Ø§Ù„Ø¯Ù‡Ù†.", price_per_kg_egp: 255, variant_name_en: "Barki (40-50kg)", variant_name_ar: "Ø¨Ø±Ù‚ÙŠ (Ù¤Ù -Ù¥Ù ÙƒØ¬Ù…)", weight_range_text_en: "40-50kg", weight_range_text_ar: "Ù¤Ù -Ù¥Ù  ÙƒØ¬Ù…", avg_weight_kg: 45, base_price_egp: (45 * 255), stock_available_pb: 5, is_active: true, sort_order_type: 2, sort_order_variant: 2 },
            { item_key: "barki_50_60", type_key: "barki", type_name_en: "Barki Sheep", type_name_ar: "Ø®Ø±ÙˆÙ Ø¨Ø±Ù‚ÙŠ", type_description_en: "Desert breed, lean meat.", type_description_ar: "Ø³Ù„Ø§Ù„Ø© ØµØ­Ø±Ø§ÙˆÙŠØ©ØŒ Ù„Ø­Ù… Ù‚Ù„ÙŠÙ„ Ø§Ù„Ø¯Ù‡Ù†.", price_per_kg_egp: 255, variant_name_en: "Barki (50-60kg)", variant_name_ar: "Ø¨Ø±Ù‚ÙŠ (Ù¥Ù -Ù¦Ù ÙƒØ¬Ù…)", weight_range_text_en: "50-60kg", weight_range_text_ar: "Ù¥Ù -Ù¦Ù  ÙƒØ¬Ù…", avg_weight_kg: 55, base_price_egp: (55 * 255), stock_available_pb: 3, is_active: true, sort_order_type: 2, sort_order_variant: 3 },
            { item_key: "barki_60_plus", type_key: "barki", type_name_en: "Barki Sheep", type_name_ar: "Ø®Ø±ÙˆÙ Ø¨Ø±Ù‚ÙŠ", type_description_en: "Desert breed, lean meat.", type_description_ar: "Ø³Ù„Ø§Ù„Ø© ØµØ­Ø±Ø§ÙˆÙŠØ©ØŒ Ù„Ø­Ù… Ù‚Ù„ÙŠÙ„ Ø§Ù„Ø¯Ù‡Ù†.", price_per_kg_egp: 255, variant_name_en: "Barki (60+kg)", variant_name_ar: "Ø¨Ø±Ù‚ÙŠ (+Ù¦Ù ÙƒØ¬Ù…)", weight_range_text_en: "60+kg", weight_range_text_ar: "+Ù¦Ù  ÙƒØ¬Ù…", avg_weight_kg: 65, base_price_egp: (65 * 255), stock_available_pb: 2, is_active: true, sort_order_type: 2, sort_order_variant: 4 }
        ]
    };

    async function authenticateAdmin(pb) {
        // ... (same as before)
        try {
            log(`Attempting admin authentication with: ${ADM_E}...`, 'i');
            await pb.admins.authWithPassword(ADM_E, ADM_P);
            log('Admin authentication successful', 's');
            return true;
        } catch (error) {
            log(`Authentication failed: ${error.message}`, 'e');
            console.error('Auth error:', error);
            if (error.response?.data) log('Auth error details:', 'e', error.response.data);
            return false;
        }
    }

    async function importCollections(pb, collectionsToImport) {
        try {
            log('Importing collections (base schema)...', 'i');
            // Ensure field options are direct properties, not nested under 'options' for each field
            const collectionsForActualImport = collectionsToImport.map(coll => {
                const newColl = {...coll};
                if (newColl.fields) { // If 'fields' exists (it should, as per our structure)
                    newColl.schema = newColl.fields.map(field => {
                        const newField = {...field};
                        if (field.options && typeof field.options === 'object') {
                            // Hoist options like max, min, pattern, values directly to the field level
                            Object.assign(newField, field.options);
                            delete newField.options; // Remove the nested 'options' for the field
                        }
                        // For select type, ensure 'values' is direct if it was under options
                        if (field.type === 'select' && field.options && field.options.values) {
                            newField.values = field.options.values;
                            if (field.options.maxSelect) newField.maxSelect = field.options.maxSelect;
                             // no need to delete newField.options if already handled above
                        }
                        return newField;
                    });
                    delete newColl.fields; // Use 'schema' for import body
                }
                // Collection-level options remain under 'options'
                if (coll.options) {
                    newColl.options = coll.options;
                }
                return newColl;
            });

            log('Collections transformed for import:', 'd', collectionsForActualImport);
            await pb.collections.import(collectionsForActualImport, false /* deleteMissing */);
            log('Collections (base schema) imported successfully', 's');
            return true;
        } catch (error) {
            log(`Collections import failed: ${error.message}`, 'e');
            console.error('Import error:', error);
            if (error.response?.data) log('Import error details:', 'e', error.response.data);
            return false;
        }
    }
    
    async function addRelationField(pb, collectionName, fieldName, targetCollectionId, isRequired = true, insertPosition = 1, displayFields = ["id"]) {
        try {
            log(`Processing relation field <b>${fieldName}</b> for <b>${collectionName}</b> to target <b>${targetCollectionId}</b>...`, 'li');
            const collection = await pb.collections.getOne(collectionName);
            const currentFields = collection.schema || []; // Use .schema here as it's the direct representation
            const fieldExists = currentFields.some(f => f.name === fieldName);

            const newFieldDefinition = {
                name: fieldName,
                type: "relation",
                required: isRequired,
                presentable: true,
                system: false, // User-defined fields are not system fields
                options: { // Relation-specific options are nested
                    collectionId: targetCollectionId,
                    cascadeDelete: false,
                    minSelect: isRequired ? 1 : null,
                    maxSelect: 1,
                    displayFields: displayFields
                }
            };

            let updatedSchemaArray; // This will be the new schema array
            if (fieldExists) {
                const existingField = currentFields.find(f => f.name === fieldName);
                if (existingField.type === 'relation' && existingField.options && existingField.options.collectionId === targetCollectionId) {
                    log(`Field <b>${fieldName}</b> already exists and is correctly configured in <b>${collectionName}</b>.`, 'lw');
                    return true;
                }
                log(`Field <b>${fieldName}</b> exists in <b>${collectionName}</b>, attempting to update to correct relation.`, 'lw');
                updatedSchemaArray = currentFields.map(f => {
                    if (f.name === fieldName) {
                        // Important: Preserve existing field 'id' if updating
                        return { id: f.id, ...newFieldDefinition };
                    }
                    return f;
                });
            } else {
                updatedSchemaArray = [...currentFields];
                // Create a temporary field definition without an 'id' for new fields
                const tempNewField = {...newFieldDefinition};
                delete tempNewField.id; // PocketBase will assign an ID
                updatedSchemaArray.splice(insertPosition, 0, tempNewField);
            }
            
            // When updating, provide the schema under the 'schema' key
            await pb.collections.update(collection.id, { schema: updatedSchemaArray }); 
            log(`Relation field <b>${fieldName}</b> in <b>${collectionName}</b> processed successfully.`, 's');
            return true;
        } catch (error) {
            log(`<b>ERROR</b> processing relation field <b>${fieldName}</b> in <b>${collectionName}</b>: ${error.message}`, 'e');
            console.error('Full error details (addRelationField):', error);
            if (error.response?.data) { log('Server Error:', 'e', error.response.data); if (error.response.data.data) { log('Validation Issues:', 'e', error.response.data.data); } }
            return false;
        }
    }


    async function seedCollectionData(pb, collectionName, seedItems, uniqueKeyField = null) {
        // ... (same as before)
        log(`Seeding data for <b>${collectionName}</b>...`, 'i');
        let createdCount = 0, updatedCount = 0, errorCount = 0;
        
        for (const item of seedItems) {
            const actualData = { ...item }; 
            try {
                let existingRecord = null;
                if (uniqueKeyField && actualData[uniqueKeyField]) {
                    existingRecord = await pb.collection(collectionName).getFirstListItem(`${uniqueKeyField}="${actualData[uniqueKeyField]}"`).catch(() => null);
                } else if (!uniqueKeyField && collectionName === "settings") { 
                    const list = await pb.collection(collectionName).getList(1, 1);
                    if (list.items.length > 0) existingRecord = list.items[0];
                }


                if (existingRecord) {
                    log(`Updating existing record in ${collectionName}`, 'd', { id: existingRecord.id, data: actualData });
                    await pb.collection(collectionName).update(existingRecord.id, actualData);
                    updatedCount++;
                } else {
                    log(`Creating new record in ${collectionName}`, 'd', actualData);
                    await pb.collection(collectionName).create(actualData);
                    createdCount++;
                }
            } catch (error) {
                log(`Error processing item in ${collectionName} (key: ${actualData[uniqueKeyField] || 'singleton'}): ${error.message}`, 'e');
                console.error('Seed error:', error);
                if (error.response?.data) log('Seed error details:', 'e', error.response.data);
                log('Failed item data:', 'e', actualData);
                errorCount++;
            }
        }
        log(`Seeding <b>${collectionName}</b> complete. Created: ${createdCount}, Updated: ${updatedCount}, Errors: ${errorCount}`, errorCount > 0 ? 'lw' : 's');
        return { created: createdCount, updated: updatedCount, errors: errorCount };
    }

    async function updateCollectionRules(pb, collectionName, rules) {
        try {
            log(`Updating rules for collection <b>${collectionName}</b>...`, 'i', rules);
            const collection = await pb.collections.getOne(collectionName);
            await pb.collections.update(collection.id, rules);
            log(`Rules for <b>${collectionName}</b> updated successfully.`, 's');
            return true;
        } catch (error) {
            log(`<b>ERROR</b> updating rules for <b>${collectionName}</b>: ${error.message}`, 'e');
            console.error('Rule update error:', error);
            if (error.response?.data) { log('Server Error (rules):', 'e', error.response.data); }
            return false;
        }
    }

    async function setupSchema(pb) {
        log('=== SCHEMA SETUP PHASE ===', 'i');
        
        if (!await authenticateAdmin(pb)) return false;
        
        // Correctly pass the collections definitions to importCollections
        const collectionsToImport = collectionsWithoutRelations.map(c => {
            // The import function expects 'schema' to contain the fields.
            // Field options (min, max, pattern, values etc.) should be direct properties of field objects.
            // Collection-level options (like maxRecords) are under 'options' for the collection.
            const schemaForImport = c.fields.map(field => {
                const fieldCopy = {...field};
                // If field.options exists and is for field-specific properties, hoist them.
                if (fieldCopy.options && typeof fieldCopy.options === 'object') {
                    // This assumes field.options was meant for field-specific properties
                    // and not for relation options (which are handled by addRelationField)
                    Object.assign(fieldCopy, fieldCopy.options); 
                    delete fieldCopy.options;
                }
                return fieldCopy;
            });
            return { ...c, schema: schemaForImport, fields: undefined }; // use 'schema', remove 'fields' for import
        });

        if (!await importCollections(pb, collectionsToImport)) return false;


        log('Step 2: Adding relation fields...', 'i');
        const productsCollection = await pb.collections.getOne('products');
        const usersCollection = await pb.collections.getOne('users'); 

        if (!productsCollection || !usersCollection) {
            log('Could not retrieve products or users collection. Aborting relation setup.', 'e');
            return false;
        }

        let relSuccess;
        relSuccess = await addRelationField(pb, 'bookings', 'user', usersCollection.id, false, 0, ["username", "email"]); 
        if (!relSuccess) { log('Failed to add "user" relation to bookings.', 'e'); return false; }

        const bookingsCollAfterUser = await pb.collections.getOne('bookings');
        const userFieldInSchema = bookingsCollAfterUser.schema.some(f => f.name === 'user');
        const productInsertPos = userFieldInSchema ? 1 : 1; 
        
        relSuccess = await addRelationField(pb, 'bookings', 'product_id', productsCollection.id, true, productInsertPos, ["item_key", "variant_name_en"]);
        if (!relSuccess) { log('Failed to add "product_id" relation to bookings.', 'e'); return false; }
        
        log('Step 3: Updating API rules for "bookings" collection AFTER relations are added...', 'i');
        const finalBookingsRules = {
            listRule: "user = @request.auth.id || ordering_person_phone = @request.data.lookup_phone", // For status check
            viewRule: "user = @request.auth.id || ordering_person_phone = @request.data.lookup_phone", // For status check
            createRule: "@request.auth.id != '' || @request.data.ordering_person_phone != ''", // Allow anonymous if phone provided
            updateRule: "user = @request.auth.id", // Only owner can update (admins implicitly can)
            deleteRule: null // Admin only delete
        };
        if (!await updateCollectionRules(pb, 'bookings', finalBookingsRules)) {
             log('Failed to update "bookings" collection rules.', 'e'); return false;
        }

        log('Schema setup completed successfully', 's');
        return true;
    }

    // ... (setupSeedData, validateProductionSecurity, validateSetup, and button handlers remain largely the same as your template)
    // Minor adjustment to seedCollectionData to handle 'settings' as truly singleton for existing check
    // Ensure validateSetup checks for the actual rules after they are applied.

    async function setupSeedData(pb) {
        log('=== SEED DATA PHASE ===', 'i');
        
        if (!await authenticateAdmin(pb)) return false;

        log('Pausing for 1 second before seeding...', 'i');
        await new Promise(resolve => setTimeout(resolve, 1000));

        await seedCollectionData(pb, 'settings', seedData.settings, null); 
        await seedCollectionData(pb, 'products', seedData.products, 'item_key');
        
        log('Seed data setup completed successfully', 's');
        return true;
    }
    
    function validateProductionSecurity() {
        // ... (same as your template, but adjust collection names/rules if needed)
        const warnings = [];
        // Check for public rules (simplified example)
        const collectionsToCheck = [
            {name: "settings", list: "", view: "", create: null, update: null, delete: null},
            {name: "products", list: "", view: "", create: "", update: "", delete: ""},
            // Bookings rules are now more complex, validate specific concerns
        ];
    
        collectionsToCheck.forEach(collectionInfo => {
            const currentCollDef = collectionsWithoutRelations.find(c => c.name === collectionInfo.name);
            if (currentCollDef) { // Check initial rules, final rules checked in validateSetup
                 if (currentCollDef.listRule === "" && currentCollDef.name !== "settings" && currentCollDef.name !== "products") warnings.push(`Collection ${currentCollDef.name} initial listRule is public.`);
                 if (currentCollDef.createRule === "") warnings.push(`Collection ${currentCollDef.name} initial createRule is public.`);
            }
        });

        const bookingsFinalRules = { // Expected secure rules for bookings
            listRule: "user = @request.auth.id || ordering_person_phone = @request.data.lookup_phone", 
            viewRule: "user = @request.auth.id || ordering_person_phone = @request.data.lookup_phone", 
            createRule: "@request.auth.id != '' || @request.data.ordering_person_phone != ''", 
            updateRule: "user = @request.auth.id", 
            deleteRule: null 
        };
        // This check is more for awareness as rules are set programmatically.
        // A direct fetch of current rules from PB would be better for live validation.
        log("Intended final 'bookings' rules for security check:", "d", bookingsFinalRules);


        if (ADM_E === 'admin@example.com' && ADM_P === 'unifiedpassword') {
            warnings.push('Using default admin credentials - CHANGE FOR PRODUCTION');
        }
        
        if (warnings.length > 0) {
            log('ðŸš¨ PRODUCTION SECURITY WARNINGS:', 'e');
            warnings.forEach(warning => log(`âš ï¸  ${warning}`, 'w'));
            log('ðŸš¨ SECURE THESE BEFORE PRODUCTION DEPLOYMENT', 'e');
        }
        
        return warnings.length === 0;
    }
    
    async function validateSetup(pb) {
        log('Validating setup...', 'i');
        const issues = [];
        if (!await authenticateAdmin(pb)) {
            issues.push("âœ— Admin authentication failed post-setup.");
            // If admin auth fails, further checks might be unreliable
            log(`Found ${issues.length} critical issues during validation`, 'e');
            issues.forEach(issue => log(issue, 'e'));
            return false;
        }

        const expectedCollections = ['settings', 'products', 'bookings', 'users'];
        let productsCollId = null;

        for (const name of expectedCollections) {
            try {
                const coll = await pb.collections.getOne(name);
                log(`âœ“ Collection ${name} (ID: ${coll.id}) exists`, 's');
                if (name === 'products') productsCollId = coll.id;

                if (name === 'bookings') {
                    const userField = coll.schema.find(f => f.name === 'user');
                    const productField = coll.schema.find(f => f.name === 'product_id');
                    if (userField && userField.type === 'relation' && userField.options.collectionId === 'users') {
                        log(`âœ“ Relation 'user' in 'bookings' correctly configured.`, 's');
                    } else {
                        issues.push(`âœ— Relation 'user' in 'bookings' MISCONFIGURED or MISSING.`);
                        log(`âœ— Relation 'user' in 'bookings' MISCONFIGURED or MISSING. Found: ${JSON.stringify(userField)}`, 'e');
                    }
                    if (productField && productField.type === 'relation' && productField.options.collectionId === productsCollId) {
                        log(`âœ“ Relation 'product_id' in 'bookings' correctly configured.`, 's');
                    } else {
                        issues.push(`âœ— Relation 'product_id' in 'bookings' MISCONFIGURED or MISSING (Expected target: ${productsCollId}).`);
                         log(`âœ— Relation 'product_id' in 'bookings' MISCONFIGURED or MISSING. Expected target: ${productsCollId}, Found: ${JSON.stringify(productField)}`, 'e');
                    }
                    // Validate rules
                    const expectedRules = {
                        listRule: "user = @request.auth.id || ordering_person_phone = @request.data.lookup_phone",
                        viewRule: "user = @request.auth.id || ordering_person_phone = @request.data.lookup_phone",
                        createRule: "@request.auth.id != '' || @request.data.ordering_person_phone != ''",
                        updateRule: "user = @request.auth.id",
                        deleteRule: null
                    };
                    for (const ruleKey in expectedRules) {
                        if (coll[ruleKey] !== expectedRules[ruleKey]) {
                             issues.push(`âœ— Rule '${ruleKey}' for 'bookings' is NOT as expected. Is: "${coll[ruleKey]}", Expected: "${expectedRules[ruleKey]}"`);
                             log(`âœ— Rule '${ruleKey}' for 'bookings' is NOT as expected. Is: "${coll[ruleKey]}", Expected: "${expectedRules[ruleKey]}"`, 'w');
                        } else {
                             log(`âœ“ Rule '${ruleKey}' for 'bookings' is as expected.`, 's');
                        }
                    }

                }
            } catch (error) {
                issues.push(`âœ— Collection ${name} missing or inaccessible.`);
                log(`âœ— Collection ${name} missing or inaccessible: ${error.message}`, 'e');
            }
        }
        
        for (const [collectionName, data] of Object.entries(seedData)) {
            if (collectionName === "settings" || collectionName === "products") { 
                try {
                    const records = await pb.collection(collectionName).getList(1, 1);
                    if (records.items.length > 0) {
                        log(`âœ“ Collection ${collectionName} has data`, 's');
                    } else {
                        issues.push(`âœ— Collection ${collectionName} is empty`);
                        log(`âœ— Collection ${collectionName} is empty`, 'w');
                    }
                } catch (error) {
                    issues.push(`âœ— Cannot access ${collectionName}: ${error.message}`);
                    log(`âœ— Cannot access ${collectionName}: ${error.message}`, 'e');
                }
            }
        }
        
        if (issues.length === 0) {
            log('âœ“ All critical validations passed', 's');
            return true;
        } else {
            log(`Found ${issues.length} critical issues during validation`, 'e');
            issues.forEach(issue => log(issue, 'e'));
            return false;
        }
    }
    // Button event handlers (runFullSetupButton, runSchemaOnlyButton, runSeedOnlyButton)
    // are largely the same as your template, just ensure they call the corrected functions.
    runFullSetupButton.onclick = async () => {
        runFullSetupButton.disabled = true;
        runSchemaOnlyButton.disabled = true;
        runSeedOnlyButton.disabled = true;
        outputDiv.innerHTML = '';
        log('=== FULL SETUP PROCESS STARTED ===', 'i');
        const pb = new PocketBase(pbUrl);
        let schemaSuccess = false;
        let seedSuccess = false;
        
        try {
            schemaSuccess = await setupSchema(pb);
            if (!schemaSuccess) {
                log('Schema setup failed, aborting full setup', 'e');
                return;
            }
            await new Promise(resolve => setTimeout(resolve, 500)); 

            seedSuccess = await setupSeedData(pb);
            if (!seedSuccess) {
                log('Seed data setup reported errors, but continuing to validation.', 'w');
            }
            await new Promise(resolve => setTimeout(resolve, 500)); 

            await validateSetup(pb);
            validateProductionSecurity();

            log('<b>=== FULL SETUP PROCESS ATTEMPTED ===</b>', schemaSuccess ? 's' : 'w'); // Success depends mainly on schema
            if (schemaSuccess) runSeedOnlyButton.disabled = false;

        } catch (error) {
            log(`<b>CRITICAL ERROR during full setup:</b> ${error.message}`, 'e');
            console.error('Full setup error:', error);
            if (error.response?.data) log('Full setup error details:', 'e', error.response.data);
            if (error.stack) log('Stack trace:', 'e', error.stack);
        } finally {
            if (pb.authStore.isValid) pb.authStore.clear();
            runFullSetupButton.disabled = false;
            runSchemaOnlyButton.disabled = false;
            log('Process finished, auth cleared', 'i');
        }
    };

    runSchemaOnlyButton.onclick = async () => {
        runFullSetupButton.disabled = true;
        runSchemaOnlyButton.disabled = true;
        runSeedOnlyButton.disabled = true;
        outputDiv.innerHTML = '';
        const pb = new PocketBase(pbUrl);
        
        try {
            const success = await setupSchema(pb);
            if (success) {
                runSeedOnlyButton.disabled = false;
                log('<b>Schema setup completed successfully</b>', 's');
                await validateSetup(pb);
                validateProductionSecurity();
            } else {
                log('<b>Schema setup failed</b>', 'e');
            }
        } catch (error) {
            log(`<b>ERROR during schema setup:</b> ${error.message}`, 'e');
            console.error('Schema error:', error);
            if (error.response?.data) log('Schema error details:', 'e', error.response.data);
        } finally {
            if (pb.authStore.isValid) pb.authStore.clear();
            runFullSetupButton.disabled = false;
            runSchemaOnlyButton.disabled = false;
        }
    };

    runSeedOnlyButton.onclick = async () => {
        runFullSetupButton.disabled = true;
        runSchemaOnlyButton.disabled = true;
        runSeedOnlyButton.disabled = true;
        outputDiv.innerHTML = '';
        const pb = new PocketBase(pbUrl);
        
        try {
            await setupSeedData(pb);
            log('<b>Seed data setup completed successfully</b>', 's');
            await validateSetup(pb); 
        } catch (error) {
            log(`<b>ERROR during seed setup:</b> ${error.message}`, 'e');
            console.error('Seed error:', error);
            if (error.response?.data) log('Seed error details:', 'e', error.response.data);
        } finally {
            if (pb.authStore.isValid) pb.authStore.clear();
            runFullSetupButton.disabled = false;
            runSchemaOnlyButton.disabled = false;
            runSeedOnlyButton.disabled = false;
        }
    };

</script>
</body>
</html>