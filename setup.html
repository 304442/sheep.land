<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PB Setup: SheepLand Udheya</title>
    <script src="https://unpkg.com/pocketbase@latest/dist/pocketbase.umd.js"></script>
    <style>
        body{font-family:sans-serif;font-size:13px;line-height:1.4;padding:10px;background:#f0f0f0;color:#333;display:flex;flex-direction:column;align-items:center;margin:0;}
        .c{max-width:700px;width:100%;background:white;padding:15px;border-radius:5px;box-shadow:0 2px 8px rgba(0,0,0,0.1);}
        h1{color:#333;border-bottom:1px solid #ccc;padding-bottom:5px;margin:0 0 10px 0;font-size:1.2em;}
        p{font-size:0.9em;margin:0 0 0.5em 0;} .warn{color:red;font-weight:bold;}
        button{padding:6px 10px;background:#007bff;color:white;border:0;border-radius:3px;cursor:pointer;font-size:0.85em;margin-bottom:5px;}
        button:disabled{background:#ccc;} button:hover:not(:disabled){background:#0056b3;}
        #out{margin-top:10px;padding:8px;background:#222;color:#eee;border-radius:3px;white-space:pre-wrap;font-family:monospace;font-size:11px;max-height:70vh;overflow-y:auto;}
        .ls{color:lime;font-weight:bold;} .le{color:salmon;font-weight:bold;} .li{color:cyan;} .lw{color:yellow;} .ld{color:gray;}
    </style>
</head>
<body>
    <div class="c">
        <h1>PB SheepLand Udheya Setup</h1>
        <p class="warn">WARNING: This script uses default admin credentials (admin@example.com / unifiedpassword). CHANGE THESE IMMEDIATELY in a production environment. This script will create/update collections and data. Backup your existing data if necessary.</p>
        <button id="runFullSetup">Run Full Setup</button>
        <button id="runSchemaOnly">Schema Only</button>
        <button id="runSeedOnly" disabled>Seed Data Only</button>
        <div id="out"></div>
    </div>
<script>
    const pbUrl = '/';
    const outputDiv = document.getElementById('out');
    const runFullSetupButton = document.getElementById('runFullSetup');
    const runSchemaOnlyButton = document.getElementById('runSchemaOnly');
    const runSeedOnlyButton = document.getElementById('runSeedOnly');
    const ADM_E = 'admin@example.com';
    const ADM_P = 'unifiedpassword';

    const log = (message, type = 'i', data = null) => {
        const timestamp = `[${new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' })}] `;
        const p = document.createElement('p');
        p.className = `l${type[0]}`;
        let logMessage = timestamp + message.replace(/</g, '<').replace(/>/g, '>');
        if (data) {
            logMessage += `\n<pre class="ld">${JSON.stringify(data, null, 2).replace(/</g, '<').replace(/>/g, '>')}</pre>`;
        }
        p.innerHTML = logMessage;
        outputDiv.appendChild(p);
        outputDiv.scrollTop = outputDiv.scrollHeight;
        const consoleMessage = timestamp + message.replace(/<[^>]*>?/gm, '');
        if (type === 'e') console.error(consoleMessage, data || '');
        else if (type === 'w') console.warn(consoleMessage, data || '');
        else if (type === 'd') console.debug(consoleMessage, data || '');
        else console.log(consoleMessage, data || '');
    };

    const collectionsWithoutRelations = [
      {
        name: "settings",
        type: "base",
        listRule: "",
        viewRule: "",
        createRule: null,
        updateRule: "@request.auth.id != '' && @request.auth.verified = true",
        deleteRule: null,
        system: false, // Explicitly false for non-system collections
        options: { "allowEmailAuth": false, "allowOAuth2Auth": false, "allowUsernameAuth": false, "exceptEmailDomains": null, "manageRule": null, "onlyEmailDomains": null, "onlyVerified": false, "requireEmail": false },
        schema: [ // PocketBase SDK uses `schema` for fields during import/update
          { name: "xchgRates", type: "json", required: true, presentable: true, system: false, id:"set_xchgr", options: {} },
          { name: "defCurr", type: "text", required: true, presentable: true, system: false, id:"set_defc", options: {max: 5, min:3, pattern:""} },
          { name: "waNumRaw", type: "text", required: false, presentable: true, system: false, id:"set_wanr", options: {max: 20, pattern:""} },
          { name: "waNumDisp", type: "text", required: false, presentable: true, system: false, id:"set_wand", options: {max: 30, pattern:""} },
          { name: "promoEndISO", type: "date", required: false, presentable: true, system: false, id:"set_promoe", options: {} },
          { name: "promoDiscPc", type: "number", required: false, presentable: true, system: false, id:"set_promod", options: {min: 0, max: 100} },
          { name: "promoActive", type: "bool", required: false, presentable: true, system: false, id:"set_promoa", options: {} },
          { name: "servFeeEGP", type: "number", required: true, presentable: true, system: false, id:"set_servf", options: {min: 0} },
          { name: "delAreas", type: "json", required: false, presentable: true, system: false, id:"set_dela", options: {} },
          { name: "payDetails", type: "json", required: false, presentable: true, system: false, id:"set_payd", options: {} }
        ],
        indexes: [] // No initial custom indexes for settings
      },
      {
        name: "products",
        type: "base",
        listRule: "",
        viewRule: "",
        createRule: "@request.auth.id != '' && @request.auth.verified = true",
        updateRule: "@request.auth.id != '' && @request.auth.verified = true",
        deleteRule: "@request.auth.id != '' && @request.auth.verified = true",
        system: false,
        options: {},
        schema: [
          { name: "item_key", type: "text", required: true, presentable: true, system: false, id:"prod_itk", options: {max: 100, min:1, pattern: "^[a-z0-9_]+$"} },
          { name: "type_key", type: "text", required: true, presentable: true, system: false, id:"prod_tyk", options: {max: 50, min:1, pattern: "^[a-z0-9_]+$"} },
          { name: "type_name_en", type: "text", required: true, presentable: true, system: false, id:"prod_tyne", options: {max: 100, min:1, pattern:""} },
          { name: "type_name_ar", type: "text", required: true, presentable: true, system: false, id:"prod_tyna", options: {max: 100, min:1, pattern:""} },
          { name: "type_description_en", type: "text", required: false, presentable: true, system: false, id:"prod_tden", options: {max: 200, pattern:""} },
          { name: "type_description_ar", type: "text", required: false, presentable: true, system: false, id:"prod_tdar", options: {max: 200, pattern:""} },
          { name: "price_per_kg_egp", type: "number", required: true, presentable: true, system: false, id:"prod_pkg", options: {min: 0} },
          { name: "variant_name_en", type: "text", required: true, presentable: true, system: false, id:"prod_vnen", options: {max: 150, min:1, pattern:""} },
          { name: "variant_name_ar", type: "text", required: true, presentable: true, system: false, id:"prod_vnar", options: {max: 150, min:1, pattern:""} },
          { name: "weight_range_text_en", type: "text", required: true, presentable: true, system: false, id:"prod_wren", options: {max: 50, min:1, pattern:""} },
          { name: "weight_range_text_ar", type: "text", required: true, presentable: true, system: false, id:"prod_wrar", options: {max: 50, min:1, pattern:""} },
          { name: "avg_weight_kg", type: "number", required: true, presentable: true, system: false, id:"prod_avgw", options: {min: 0} },
          { name: "base_price_egp", type: "number", required: true, presentable: true, system: false, id:"prod_bpr", options: {min: 0} },
          { name: "stock_available_pb", type: "number", required: true, presentable: true, system: false, id:"prod_stk", options: {min: 0, noDecimal: true} },
          { name: "is_active", type: "bool", required: false, presentable: true, system: false, id:"prod_isact", options: {} },
          { name: "sort_order_type", type: "number", required: false, presentable: true, system: false, id:"prod_sot", options: {min: 0, noDecimal: true} },
          { name: "sort_order_variant", type: "number", required: false, presentable: true, system: false, id:"prod_sov", options: {min: 0, noDecimal: true} }
        ],
        indexes: [ "CREATE UNIQUE INDEX `idx_products_item_key` ON `products` (`item_key`)" ]
      },
      {
        name: "sheep_log",
        type: "base",
        listRule: "@request.auth.id != '' && @request.auth.verified = true",
        viewRule: "@request.auth.id != '' && @request.auth.verified = true",
        createRule: "@request.auth.id != '' && @request.auth.verified = true",
        updateRule: "@request.auth.id != '' && @request.auth.verified = true",
        deleteRule: "@request.auth.id != '' && @request.auth.verified = true",
        system: false,
        options: {},
        schema: [
          { name: "animal_tag_id", type: "text", required: true, presentable: true, system: false, id:"sl_tag", options: {max: 50, min:1, pattern: "^[a-zA-Z0-9_-]+$"} },
          { name: "species", type: "text", required: true, presentable: true, system: false, id:"sl_spc", options: {max: 50, min:1, pattern:""} },
          { name: "breed", type: "text", required: false, presentable: true, system: false, id:"sl_brd", options: {max: 100, pattern:""} },
          { name: "date_of_birth", type: "date", required: false, presentable: true, system: false, id:"sl_dob", options: {} },
          { name: "acquisition_date", type: "date", required: true, presentable: true, system: false, id:"sl_acqd", options: {} },
          { name: "acquisition_cost_egp", type: "number", required: false, presentable: true, system: false, id:"sl_acqc", options: {min: 0} },
          { name: "source", type: "text", required: false, presentable: true, system: false, id:"sl_src", options: {max: 150, pattern:""} },
          { name: "gender", type: "select", required: false, presentable: true, system: false, id:"sl_gen", options: {maxSelect: 1, values: ["Male", "Female", "Unknown"]} },
          { name: "initial_weight_kg", type: "number", required: false, presentable: true, system: false, id:"sl_initw", options: {min: 0} },
          { name: "current_status", type: "select", required: true, presentable: true, system: false, id:"sl_stat", options: {maxSelect: 1, values: ["Active", "Sold", "Deceased", "Culled", "Quarantined", "Reserved"]} },
          { name: "notes", type: "text", required: false, presentable: true, system: false, id:"sl_nts", options: {max: 1000, pattern:""} },
          { name: "product_item_key_association", type: "text", required: false, presentable: true, system: false, id:"sl_prda", options: {max: 100, pattern: "^[a-z0-9_]*$"} }
          // sale_order_id (relation) will be added in step 2
        ],
        indexes: [ "CREATE UNIQUE INDEX `idx_sheep_log_animal_tag_id` ON `sheep_log` (`animal_tag_id`)" ]
      },
      {
        name: "animal_events",
        type: "base",
        listRule: "@request.auth.id != '' && @request.auth.verified = true",
        viewRule: "@request.auth.id != '' && @request.auth.verified = true",
        createRule: "@request.auth.id != '' && @request.auth.verified = true",
        updateRule: "@request.auth.id != '' && @request.auth.verified = true",
        deleteRule: "@request.auth.id != '' && @request.auth.verified = true",
        system: false,
        options: {},
        schema: [
          // animal_id (relation) will be added in step 2
          { name: "event_date", type: "date", required: true, presentable: true, system: false, id:"ae_evd", options: {} },
          { name: "event_type", type: "select", required: true, presentable: true, system: false, id:"ae_evt", options: {maxSelect: 1, values: ["Vaccination", "Medication", "Feeding Change", "Weight Check", "Breeding", "Birth (Offspring)", "Injury", "Illness", "Relocation", "Status Change", "Other"]} },
          { name: "description", type: "text", required: true, presentable: true, system: false, id:"ae_dsc", options: {max: 500, min:1, pattern:""} },
          { name: "cost_associated_egp", type: "number", required: false, presentable: true, system: false, id:"ae_cst", options: {min: 0} },
          { name: "vet_involved", type: "text", required: false, presentable: true, system: false, id:"ae_vet", options: {max: 100, pattern:""} },
          { name: "medication_details", type: "text", required: false, presentable: true, system: false, id:"ae_med", options: {max: 200, pattern:""} },
          { name: "weight_kg_at_event", type: "number", required: false, presentable: true, system: false, id:"ae_wkg", options: {min: 0} },
          { name: "notes", type: "text", required: false, presentable: true, system: false, id:"ae_nts", options: {max: 1000, pattern:""} }
        ],
        indexes: [ "CREATE INDEX `idx_animal_events_event_date` ON `animal_events` (`event_date`)" ]
      },
      {
        name: "orders",
        type: "base",
        listRule: "@request.auth.id != '' && @request.auth.verified = true", // Initial restrictive, updated later
        viewRule: "@request.auth.id != '' && @request.auth.verified = true", // Initial restrictive, updated later
        createRule: "", // API hook will create
        updateRule: "@request.auth.id != '' && @request.auth.verified = true",
        deleteRule: "@request.auth.id != '' && @request.auth.verified = true",
        system: false,
        options: {},
        schema: [
          // Relations (user, product_id, animal_id) will be added in step 2
          { name: "order_id_text", type: "text", required: true, presentable: true, system: false, id:"ord_oid", options: {max: 50, min:1, pattern:""} },
          { name: "ordered_product_name_en", type: "text", required: true, presentable: true, system: false, id:"ord_opne", options: {max: 150, min:1, pattern:""} },
          { name: "ordered_product_name_ar", type: "text", required: true, presentable: true, system: false, id:"ord_opna", options: {max: 150, min:1, pattern:""} },
          { name: "ordered_weight_range_en", type: "text", required: true, presentable: true, system: false, id:"ord_owre", options: {max: 50, min:1, pattern:""} },
          { name: "ordered_weight_range_ar", type: "text", required: true, presentable: true, system: false, id:"ord_owra", options: {max: 50, min:1, pattern:""} },
          { name: "price_at_order_time_egp", type: "number", required: true, presentable: true, system: false, id:"ord_prce", options: {min: 0} },
          { name: "cost_of_animal_egp", type: "number", required: false, presentable: false, system: false, id:"ord_coae", options: {min: 0} },
          { name: "udheya_service_option_selected", type: "text", required: true, presentable: true, system: false, id:"ord_usos", options: {max: 50, min:1, pattern:""} },
          { name: "service_fee_applied_egp", type: "number", required: true, presentable: true, system: false, id:"ord_sfee", options: {min: 0} },
          { name: "delivery_fee_applied_egp", type: "number", required: false, presentable: true, system: false, id:"ord_dfee", options: {min: 0} },
          { name: "total_amount_due_egp", type: "number", required: true, presentable: true, system: false, id:"ord_tamt", options: {min: 0} },
          { name: "selected_display_currency", type: "text", required: false, presentable: true, system: false, id:"ord_sdc", options: {max: 5, pattern:""} },
          { name: "sacrifice_day_value", type: "text", required: true, presentable: true, system: false, id:"ord_scdv", options: {max: 50, min:1, pattern:""} },
          { name: "sacrifice_day_text_en", type: "text", required: false, presentable: true, system: false, id:"ord_scde", options: {max: 100, pattern:""} },
          { name: "sacrifice_day_text_ar", type: "text", required: false, presentable: true, system: false, id:"ord_scda", options: {max: 100, pattern:""} },
          { name: "slaughter_viewing_preference", type: "text", required: false, presentable: true, system: false, id:"ord_svpr", options: {max: 50, pattern:""} },
          { name: "distribution_choice", type: "text", required: false, presentable: true, system: false, id:"ord_dch", options: {max: 50, pattern:""} },
          { name: "split_details_option", type: "text", required: false, presentable: true, system: false, id:"ord_sdo", options: {max: 100, pattern:""} },
          { name: "custom_split_details_text", type: "text", required: false, presentable: true, system: false, id:"ord_csdt", options: {max: 500, pattern:""} },
          { name: "niyyah_names", type: "text", required: false, presentable: true, system: false, id:"ord_niy", options: {max: 500, pattern:""} },
          { name: "ordering_person_name", type: "text", required: true, presentable: true, system: false, id:"ord_opnm", options: {max: 150, min:1, pattern:""} },
          { name: "ordering_person_phone", type: "text", required: true, presentable: true, system: false, id:"ord_opph", options: {max: 30, min:7, pattern:""} },
          { name: "customer_email", type: "email", required: false, presentable: true, system: false, id:"ord_cuse", options: {exceptDomains: null, onlyDomains: null} },
          { name: "delivery_option", type: "text", required: false, presentable: true, system: false, id:"ord_delo", options: {max: 50, pattern:""} },
          { name: "delivery_name", type: "text", required: false, presentable: true, system: false, id:"ord_deln", options: {max: 150, pattern:""} },
          { name: "delivery_phone", type: "text", required: false, presentable: true, system: false, id:"ord_delp", options: {max: 30, pattern:""} },
          { name: "delivery_area_id", type: "text", required: false, presentable: true, system: false, id:"ord_delaid", options: {max: 50, pattern:""} },
          { name: "delivery_area_name_en", type: "text", required: false, presentable: true, system: false, id:"ord_delane", options: {max: 100, pattern:""} },
          { name: "delivery_area_name_ar", type: "text", required: false, presentable: true, system: false, id:"ord_delana", options: {max: 100, pattern:""} },
          { name: "delivery_address", type: "text", required: false, presentable: true, system: false, id:"ord_delad", options: {max: 500, pattern:""} },
          { name: "delivery_instructions", type: "text", required: false, presentable: true, system: false, id:"ord_delins", options: {max: 500, pattern:""} },
          { name: "time_slot", type: "text", required: false, presentable: true, system: false, id:"ord_tslo", options: {max: 50, pattern:""} },
          { name: "payment_method", type: "text", required: true, presentable: true, system: false, id:"ord_paym", options: {max: 50, min:1, pattern:""} },
          { name: "payment_status", type: "select", required: true, presentable: true, system: false, id:"ord_pays", options: {maxSelect: 1, values: ["pending_payment", "payment_under_review", "paid_confirmed", "cod_pending_confirmation", "cod_confirmed_pending_delivery", "failed", "refunded", "partially_refunded"]} },
          { name: "order_status", type: "select", required: true, presentable: true, system: false, id:"ord_ords", options: {maxSelect: 1, values: ["pending_confirmation", "confirmed_pending_payment", "payment_confirmed_processing", "ready_for_fulfillment", "out_for_delivery", "fulfilled_completed", "cancelled_by_user", "cancelled_by_admin", "on_hold"]} },
          { name: "terms_agreed", type: "bool", required: false, presentable: true, system: false, id:"ord_term", options: {} },
          { name: "admin_notes", type: "text", required: false, presentable: false, system: false, id:"ord_admn", options: {max: 1000, pattern:""} },
          { name: "group_purchase_interest", type: "bool", required: false, presentable: true, system: false, id:"ord_gpi", options: {} },
          { name: "user_ip_address", type: "text", required: false, presentable: false, system: false, id:"ord_uip", options: {max: 50, pattern:""} },
          { name: "user_agent_string", type: "text", required: false, presentable: false, system: false, id:"ord_uas", options: {max: 300, pattern:""} }
        ],
        indexes: [ "CREATE UNIQUE INDEX `idx_orders_order_id_text` ON `orders` (`order_id_text`)" ]
      },
      {
        name: "expenses",
        type: "base",
        listRule: "@request.auth.id != '' && @request.auth.verified = true",
        viewRule: "@request.auth.id != '' && @request.auth.verified = true",
        createRule: "@request.auth.id != '' && @request.auth.verified = true",
        updateRule: "@request.auth.id != '' && @request.auth.verified = true",
        deleteRule: "@request.auth.id != '' && @request.auth.verified = true",
        system: false,
        options: {},
        schema: [
          { name: "expense_date", type: "date", required: true, presentable: true, system: false, id:"exp_exd", options: {} },
          { name: "category", type: "text", required: true, presentable: true, system: false, id:"exp_cat", options: {max: 100, min:1, pattern:""} },
          { name: "description", type: "text", required: true, presentable: true, system: false, id:"exp_dsc", options: {max: 500, min:1, pattern:""} },
          { name: "amount_egp", type: "number", required: true, presentable: true, system: false, id:"exp_amt", options: {min: 0} },
          { name: "vendor", type: "text", required: false, presentable: true, system: false, id:"exp_ven", options: {max: 150, pattern:""} },
          { name: "payment_method", type: "text", required: false, presentable: true, system: false, id:"exp_paym", options: {max: 50, pattern:""} },
          { name: "receipt", type: "file", required: false, presentable: true, system: false, id:"exp_rcpt", options: {maxSelect: 1, maxSize: 5242880, mimeTypes: ["image/jpeg", "image/png", "image/gif", "application/pdf"]} },
          { name: "notes", type: "text", required: false, presentable: true, system: false, id:"exp_nts", options: {max: 1000, pattern:""} }
        ],
        indexes: [
            "CREATE INDEX `idx_expenses_date` ON `expenses` (`expense_date`)",
            "CREATE INDEX `idx_expenses_category` ON `expenses` (`category`)"
        ]
      }
    ];

    // Seed data (same as provided previously, ensure it matches the schema without relations first)
    const seedData = {
        settings: [ {
                xchgRates: { EGP: { rate_from_egp: 1, symbol: "LE", is_active: true }, USD: { rate_from_egp: 0.020, symbol: "$", is_active: true }, GBP: { rate_from_egp: 0.015, symbol: "¬£", is_active: true } },
                defCurr: "EGP", waNumRaw: "201117117489", waNumDisp: "+20 11 1711 7489", promoEndISO: new Date(Date.now() + 15 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], promoDiscPc: 10, promoActive: true, servFeeEGP: 750,
                delAreas: [ { id: "giza_west", name_en: "Giza West", name_ar: "ÿ∫ÿ±ÿ® ÿßŸÑÿ¨Ÿäÿ≤ÿ©", cities: [ { id: "october", name_en: "6th of October City", name_ar: "ŸÖÿØŸäŸÜÿ© 6 ÿ£ŸÉÿ™Ÿàÿ®ÿ±", delivery_fee_egp: 150 }, { id: "zayed", name_en: "Sheikh Zayed", name_ar: "ÿßŸÑÿ¥ŸäÿÆ ÿ≤ÿßŸäÿØ", delivery_fee_egp: 150 }, { id: "euro_reef", name_en: "European Reef", name_ar: "ÿßŸÑÿ±ŸäŸÅ ÿßŸÑÿ£Ÿàÿ±Ÿàÿ®Ÿâ", delivery_fee_egp: 150 } ] }, { id:"cairo", name_en:"Cairo", name_ar:"ÿßŸÑŸÇÿßŸáÿ±ÿ©", cities:[ {id:"nasr_city", name_en:"Nasr City", name_ar:"ŸÖÿØŸäŸÜÿ© ŸÜÿµÿ±", delivery_fee_egp: 250 }, {id:"maadi", name_en:"Maadi", name_ar:"ÿßŸÑŸÖÿπÿßÿØŸä", delivery_fee_egp: 250 }, {id:"heliopolis", name_en:"Heliopolis", name_ar:"ŸÖÿµÿ± ÿßŸÑÿ¨ÿØŸäÿØÿ©", delivery_fee_egp: 250} ] } ],
                payDetails: { vodafone_cash: "01076543210", instapay_ipn: "seed_user@instapay", revolut_details: "@seedUserRevolut", monzo_details: "monzo.me/seeduser", bank_name: "Seed Bank Egypt", bank_account_name: "Sheep Land Seed Account", bank_account_number: "1234567890123456", bank_iban: "EG00123400000000001234567890", bank_swift: "SEEDBANKEGCA" }
            }
        ],
        products: [
            { item_key: "baladi_40_50", type_key: "baladi", type_name_en: "Baladi Sheep", type_name_ar: "ÿÆÿ±ŸàŸÅ ÿ®ŸÑÿØŸä", type_description_en: "Local breed, rich flavor.", type_description_ar: "ÿ≥ŸÑÿßŸÑÿ© ŸÖÿ≠ŸÑŸäÿ©ÿå ŸÜŸÉŸáÿ© ÿ∫ŸÜŸäÿ©.", price_per_kg_egp: 230, variant_name_en: "Baladi (40-50kg)", variant_name_ar: "ÿ®ŸÑÿØŸä (Ÿ§Ÿ†-Ÿ•Ÿ†ŸÉÿ¨ŸÖ)", weight_range_text_en: "40-50kg", weight_range_text_ar: "Ÿ§Ÿ†-Ÿ•Ÿ† ŸÉÿ¨ŸÖ", avg_weight_kg: 45, base_price_egp: 10350, stock_available_pb: 7, is_active: true, sort_order_type: 1, sort_order_variant: 1 },
            { item_key: "baladi_50_60", type_key: "baladi", type_name_en: "Baladi Sheep", type_name_ar: "ÿÆÿ±ŸàŸÅ ÿ®ŸÑÿØŸä", type_description_en: "Local breed, rich flavor.", type_description_ar: "ÿ≥ŸÑÿßŸÑÿ© ŸÖÿ≠ŸÑŸäÿ©ÿå ŸÜŸÉŸáÿ© ÿ∫ŸÜŸäÿ©.", price_per_kg_egp: 230, variant_name_en: "Baladi (50-60kg)", variant_name_ar: "ÿ®ŸÑÿØŸä (Ÿ•Ÿ†-Ÿ¶Ÿ†ŸÉÿ¨ŸÖ)", weight_range_text_en: "50-60kg", weight_range_text_ar: "Ÿ•Ÿ†-Ÿ¶Ÿ† ŸÉÿ¨ŸÖ", avg_weight_kg: 55, base_price_egp: 12650, stock_available_pb: 8, is_active: true, sort_order_type: 1, sort_order_variant: 2 },
            { item_key: "baladi_60_plus", type_key: "baladi", type_name_en: "Baladi Sheep", type_name_ar: "ÿÆÿ±ŸàŸÅ ÿ®ŸÑÿØŸä", type_description_en: "Local breed, rich flavor.", type_description_ar: "ÿ≥ŸÑÿßŸÑÿ© ŸÖÿ≠ŸÑŸäÿ©ÿå ŸÜŸÉŸáÿ© ÿ∫ŸÜŸäÿ©.", price_per_kg_egp: 230, variant_name_en: "Baladi (60+kg)", variant_name_ar: "ÿ®ŸÑÿØŸä (+Ÿ¶Ÿ†ŸÉÿ¨ŸÖ)", weight_range_text_en: "60+kg", weight_range_text_ar: "+Ÿ¶Ÿ† ŸÉÿ¨ŸÖ", avg_weight_kg: 65, base_price_egp: 14950, stock_available_pb: 3, is_active: true, sort_order_type: 1, sort_order_variant: 3 },
            { item_key: "barki_40_50", type_key: "barki", type_name_en: "Barki Sheep", type_name_ar: "ÿÆÿ±ŸàŸÅ ÿ®ÿ±ŸÇŸä", type_description_en: "Desert breed, lean meat.", type_description_ar: "ÿ≥ŸÑÿßŸÑÿ© ÿµÿ≠ÿ±ÿßŸàŸäÿ©ÿå ŸÑÿ≠ŸÖ ŸÇŸÑŸäŸÑ ÿßŸÑÿØŸáŸÜ.", price_per_kg_egp: 255, variant_name_en: "Barki (40-50kg)", variant_name_ar: "ÿ®ÿ±ŸÇŸä (Ÿ§Ÿ†-Ÿ•Ÿ†ŸÉÿ¨ŸÖ)", weight_range_text_en: "40-50kg", weight_range_text_ar: "Ÿ§Ÿ†-Ÿ•Ÿ† ŸÉÿ¨ŸÖ", avg_weight_kg: 45, base_price_egp: 11475, stock_available_pb: 5, is_active: true, sort_order_type: 2, sort_order_variant: 2 }
        ],
        sheep_log: [ // sale_order_id will be null initially as orders don't exist yet or are seeded later
            { animal_tag_id: "SL-B-001", species: "Sheep", breed: "Baladi", acquisition_date: new Date(new Date().setDate(new Date().getDate()-60)).toISOString().split('T')[0], acquisition_cost_egp: 6500, source: "Farm Born", gender: "Male", initial_weight_kg: 15, current_status: "Active", product_item_key_association: "baladi_50_60"},
            { animal_tag_id: "SL-B-002", species: "Sheep", breed: "Baladi", acquisition_date: new Date(new Date().setDate(new Date().getDate()-60)).toISOString().split('T')[0], acquisition_cost_egp: 6800, source: "Al-Amin Market", gender: "Male", initial_weight_kg: 18, current_status: "Active", product_item_key_association: "baladi_60_plus"},
            { animal_tag_id: "SL-K-001", species: "Sheep", breed: "Barki", acquisition_date: new Date(new Date().setDate(new Date().getDate()-45)).toISOString().split('T')[0], acquisition_cost_egp: 5500, source: "Supplier Z", gender: "Female", initial_weight_kg: 12, current_status: "Active", product_item_key_association: "barki_40_50"}
        ],
        animal_events: [ // animal_id (relation) will be resolved during seeding process if animals exist
            { animal_tag_id_for_seed: "SL-B-001", event_date: new Date(new Date().setDate(new Date().getDate()-30)).toISOString().split('T')[0], event_type: "Vaccination", description: "Annual booster shots", cost_associated_egp: 50},
            { animal_tag_id_for_seed: "SL-B-001", event_date: new Date(new Date().setDate(new Date().getDate()-5)).toISOString().split('T')[0], event_type: "Weight Check", description: "Routine weight check", weight_kg_at_event: 48},
            { animal_tag_id_for_seed: "SL-K-001", event_date: new Date(new Date().setDate(new Date().getDate()-20)).toISOString().split('T')[0], event_type: "Medication", description: "Deworming", cost_associated_egp: 75, medication_details: "Ivermectin Oral Solution"}
        ],
        expenses: [
            { expense_date: new Date(new Date().setDate(new Date().getDate()-15)).toISOString().split('T')[0], category: "Animal Feed", description: "Initial stock of hay and grains", amount_egp: 5000, vendor: "Al-Baraka Feeds", payment_method: "Bank Transfer"},
            { expense_date: new Date(new Date().setDate(new Date().getDate()-10)).toISOString().split('T')[0], category: "Vet Services", description: "Health checkup for new arrivals", amount_egp: 1200, vendor: "Dr. Saleh Vet Clinic", payment_method: "Cash"}
        ]
    };

    async function authenticateAdmin(pb) {
        try {
            log(`Attempting admin authentication with: ${ADM_E}...`, 'i');
            await pb.admins.authWithPassword(ADM_E, ADM_P);
            log('Admin authentication successful', 's');
            return true;
        } catch (error) {
            log(`Authentication failed: ${error.message}`, 'e');
            console.error('Auth error:', error);
            if (error.response?.data) log('Auth error details:', 'e', error.response.data);
            return false;
        }
    }

    async function importCollections(pb, collectionsToImport) {
        try {
            log('Importing base collections (step 1/3)...', 'i');
            // The import method expects an array of Collection an objects.
            // Ensure collectionsToImport matches this structure.
            // The `deleteMissing` flag is false by default, which is good here.
            log('Collections to be imported:', 'd', collectionsToImport);
            await pb.collections.import(collectionsToImport, false); // false: do not delete missing collections
            log('Base collections imported/updated successfully', 's');
            return true;
        } catch (error) {
            log(`Base collections import/update failed: ${error.message}`, 'e');
            console.error('Import error:', error);
            if (error.response?.data) log('Import error details:', 'e', error.response.data);
            return false;
        }
    }

    async function addOrUpdateRelationField(pb, collectionName, fieldDefinition, insertPosition = -1) {
        try {
            log(`Handling relation field <b>${fieldDefinition.name}</b> in <b>${collectionName}</b>...`, 'i');
            const collection = await pb.collections.getOne(collectionName);
            const existingFieldIndex = collection.schema.findIndex(f => f.name === fieldDefinition.name);
            
            let updatedSchema = [...collection.schema];

            if (existingFieldIndex > -1) {
                log(`Field <b>${fieldDefinition.name}</b> already exists in <b>${collectionName}</b>. Updating options if different.`, 'w');
                // Preserve ID and System status, update the rest
                const existingField = updatedSchema[existingFieldIndex];
                updatedSchema[existingFieldIndex] = {
                    ...existingField, // Keep original id, system
                    type: fieldDefinition.type,
                    required: fieldDefinition.required,
                    presentable: fieldDefinition.presentable,
                    options: fieldDefinition.options
                };
            } else {
                log(`Adding new relation field <b>${fieldDefinition.name}</b> to <b>${collectionName}</b>.`, 'd');
                // Generate a temporary client-side ID for new fields if PocketBase requires it for schema updates (usually not for new fields)
                // fieldDefinition.id = fieldDefinition.id || 'new_' + Math.random().toString(36).substr(2, 5); 
                if (insertPosition === -1 || insertPosition >= updatedSchema.length) {
                    updatedSchema.push(fieldDefinition);
                } else {
                    updatedSchema.splice(insertPosition, 0, fieldDefinition);
                }
            }
            
            await pb.collections.update(collection.id, { schema: updatedSchema });
            log(`Relation field <b>${fieldDefinition.name}</b> in <b>${collectionName}</b> handled successfully`, 's');
            return true;
        } catch (error) {
            log(`Error handling relation field ${fieldDefinition.name} in ${collectionName}: ${error.message}`, 'e');
            console.error('Relation field error:', error);
            if (error.response?.data) log('Relation field error details:', 'e', error.response.data);
            return false;
        }
    }


    async function setupAllRelations(pb) {
        log('Setting up relation fields (step 2/3)...', 'i');
        
        // Define relation fields to be added/updated
        // These reference collections by NAME. The import function or collection creation
        // should have already created these collections.
        const relationsToAdd = [
            {
                collectionName: "orders",
                field: { name: "user", type: "relation", required: false, presentable: true, system: false, id: "ord_usr", options: { collectionId: "users", cascadeDelete: false, minSelect: null, maxSelect: 1, displayFields: ["email", "username"] } },
                position: 0
            },
            {
                collectionName: "orders",
                field: { name: "product_id", type: "relation", required: true, presentable: true, system: false, id: "ord_prdid", options: { collectionId: "products", cascadeDelete: false, minSelect: 1, maxSelect: 1, displayFields: ["item_key", "variant_name_en"] } },
                position: 1
            },
            {
                collectionName: "orders",
                field: { name: "animal_id", type: "relation", required: false, presentable: true, system: false, id: "ord_anid", options: { collectionId: "sheep_log", cascadeDelete: false, minSelect: null, maxSelect: 1, displayFields: ["animal_tag_id"] } },
                position: 2
            },
            {
                collectionName: "animal_events",
                field: { name: "animal_id", type: "relation", required: true, presentable: true, system: false, id: "ae_anid", options: { collectionId: "sheep_log", cascadeDelete: true, minSelect: 1, maxSelect: 1, displayFields: ["animal_tag_id"] } },
                position: 0
            },
            {
                collectionName: "sheep_log", // Add the sale_order_id relation here
                field: { name: "sale_order_id", type: "relation", required: false, presentable: true, system: false, id: "sl_soid", options: { collectionId: "orders", cascadeDelete: false, minSelect: null, maxSelect: 1, displayFields: ["order_id_text"] } },
                position: -1 // Add to end
            }
        ];

        for (const rel of relationsToAdd) {
            // We pass the full fieldDefinition object to addOrUpdateRelationField
            if (!await addOrUpdateRelationField(pb, rel.collectionName, rel.field, rel.position)) {
                log(`Failed to process relation for ${rel.collectionName}.${rel.field.name}. Halting relation setup.`, 'e');
                return false; // Stop if one relation fails
            }
        }
        log('All relation fields processed.', 's');
        return true;
    }
    
    async function updateOrderCollectionRules(pb) {
        log('Updating final rules for "orders" collection (step 3/3)...', 'i');
        const finalOrdersRules = {
            listRule: "@request.auth.id = user.id || ordering_person_phone = @request.query.lookupPhone:string",
            viewRule: "@request.auth.id = user.id || ordering_person_phone = @request.query.lookupPhone:string",
            createRule: "@request.auth.id != '' || ordering_person_phone != ''", 
            updateRule: "@request.auth.id != '' && @request.auth.verified = true", 
            deleteRule: "@request.auth.id != '' && @request.auth.verified = true"
        };
        try {
            const ordersCollection = await pb.collections.getOne("orders");
            await pb.collections.update(ordersCollection.id, finalOrdersRules);
            log('Successfully updated "orders" collection rules.', 's');
            return true;
        } catch (error) {
            log(`Failed to update "orders" collection rules: ${error.message}`, 'e');
            console.error("Rule update error:", error);
            if (error.response?.data) log('Rule update error details:', 'e', error.response.data);
            return false;
        }
    }


    async function seedCollectionData(pb, collectionName, seedItems, uniqueKeyField = null, relationMappings = {}) {
        log(`Seeding data for <b>${collectionName}</b>...`, 'i');
        let createdCount = 0, updatedCount = 0, errorCount = 0;
        
        for (const item of seedItems) {
            const processedItem = { ...item }; // Work on a copy

            // Resolve relation placeholders to actual IDs
            for (const [placeholderField, config] of Object.entries(relationMappings)) {
                if (processedItem[placeholderField] !== undefined && processedItem[placeholderField] !== null) {
                    try {
                        const relatedRecord = await pb.collection(config.collection)
                            .getFirstListItem(`${config.field}="${pb.utils.escapeFilterValue(processedItem[placeholderField])}"`);
                        processedItem[config.targetField] = relatedRecord.id; // Assign resolved ID to the actual relation field
                        log(`Resolved relation for ${collectionName}: ${placeholderField} (${processedItem[placeholderField]}) to ${config.targetField} = ${relatedRecord.id}`, 'd');
                    } catch (error) {
                        log(`Failed to resolve relation ${placeholderField} for item in ${collectionName} (value: ${processedItem[placeholderField]}): ${error.message}. Skipping relation for this item.`, 'w');
                        // Do not set the target field if resolution fails, or set to null if appropriate
                        processedItem[config.targetField] = null; 
                    }
                    delete processedItem[placeholderField]; // Remove the placeholder
                } else {
                     delete processedItem[placeholderField]; // Remove placeholder if it's null/undefined
                }
            }
            
            try {
                let existingRecord = null;
                if (uniqueKeyField && processedItem[uniqueKeyField] !== undefined) { // Check processedItem for the key
                    existingRecord = await pb.collection(collectionName).getFirstListItem(`${uniqueKeyField}="${pb.utils.escapeFilterValue(processedItem[uniqueKeyField])}"`).catch(() => null);
                } else if (!uniqueKeyField && collectionName === "settings") { // Special case for singleton settings
                    const list = await pb.collection(collectionName).getList(1, 1, { requestKey: null });
                    if (list.items.length > 0) existingRecord = list.items[0];
                }

                if (existingRecord) {
                    log(`Updating existing record in ${collectionName}`, 'd', { id: existingRecord.id, data: processedItem });
                    await pb.collection(collectionName).update(existingRecord.id, processedItem);
                    updatedCount++;
                } else {
                    log(`Creating new record in ${collectionName}`, 'd', processedItem);
                    await pb.collection(collectionName).create(processedItem);
                    createdCount++;
                }
            } catch (error) {
                log(`Error processing item in ${collectionName}: ${error.message}`, 'e');
                console.error('Seed error:', error);
                if (error.response?.data) log('Seed error details:', 'e', error.response.data);
                log('Failed item data (after relation processing):', 'e', processedItem);
                errorCount++;
            }
        }
        log(`Seeding <b>${collectionName}</b> complete. Created: ${createdCount}, Updated: ${updatedCount}, Errors: ${errorCount}`, errorCount > 0 ? 'w' : 's');
        return { created: createdCount, updated: updatedCount, errors: errorCount };
    }

    async function setupSchema(pb) {
        log('=== SCHEMA SETUP PHASE ===', 'i');
        if (!await authenticateAdmin(pb)) return false;

        // Step 1: Import collections WITHOUT relations defined in their schema initially.
        // Relations are defined in a separate step.
        if (!await importCollections(pb, collectionsWithoutRelations)) return false;
        await new Promise(resolve => setTimeout(resolve, 500)); // Small delay

        // Step 2: Add/Update relation fields to the now existing collections.
        if (!await setupAllRelations(pb)) return false;
        await new Promise(resolve => setTimeout(resolve, 500)); // Small delay

        // Step 3: Update specific collection rules (e.g., for orders)
        if(!await updateOrderCollectionRules(pb)) return false;


        log('Schema setup completed successfully', 's');
        return true;
    }

    async function setupSeedData(pb) {
        log('=== SEED DATA PHASE ===', 'i');
        if (!await authenticateAdmin(pb)) return false;

        log('Pausing for 1 second before seeding...', 'i');
        await new Promise(resolve => setTimeout(resolve, 1000));

        await seedCollectionData(pb, 'settings', seedData.settings);
        await seedCollectionData(pb, 'products', seedData.products, 'item_key');
        await seedCollectionData(pb, 'sheep_log', seedData.sheep_log, 'animal_tag_id');
        
        // Seed animal_events with relation resolution
        await seedCollectionData(pb, 'animal_events', seedData.animal_events, null, {
            animal_tag_id_for_seed: { collection: 'sheep_log', field: 'animal_tag_id', targetField: 'animal_id' }
        });
        
        await seedCollectionData(pb, 'expenses', seedData.expenses);

        log('Seed data setup completed successfully', 's');
        return true;
    }
    
    function validateProductionSecurity() {
        const warnings = [];
        collectionsWithoutRelations.forEach(collection => { // Check initial definitions for public access
            if (collection.listRule === "" && !['settings', 'products'].includes(collection.name) ) warnings.push(`Collection ${collection.name} initial listRule is public.`);
            if (collection.viewRule === "" && !['settings', 'products'].includes(collection.name) ) warnings.push(`Collection ${collection.name} initial viewRule is public.`);
            if (collection.createRule === "" && collection.name !== 'orders' ) warnings.push(`Collection ${collection.name} initial createRule is public.`); // Orders create is via hook
            // updateRule and deleteRule are usually more restrictive from the start
        });
        // After setup, 'orders' rules should be more specific. This check is for initial definitions.
        if (ADM_E === 'admin@example.com' || ADM_P === 'unifiedpassword') {
            warnings.push('Using default admin credentials - CHANGE FOR PRODUCTION');
        }
        if (warnings.length > 0) {
            log('üö® PRODUCTION SECURITY WARNINGS:', 'e');
            warnings.forEach(warning => log(`‚ö†Ô∏è  ${warning}`, 'w'));
            log('üö® SECURE THESE BEFORE PRODUCTION DEPLOYMENT', 'e');
        } else {
            log('‚úì Basic production security checks passed (default admin credentials still need manual change if applicable).', 's');
        }
        return warnings.length === 0;
    }

    async function validateSetup(pb) { // Simplified validation, more checks can be added
        log('Validating setup...', 'i');
        const issues = [];
        
        try {
            const expectedCollections = ['settings', 'products', 'orders', 'users', 'expenses', 'sheep_log', 'animal_events'];
            for (const name of expectedCollections) {
                try {
                    await pb.collections.getOne(name);
                    log(`‚úì Collection ${name} exists`, 's');
                } catch (error) {
                    issues.push(`‚úó Collection ${name} missing`);
                    log(`‚úó Collection ${name} missing`, 'e');
                }
            }
            // Add more specific field/relation/rule checks if needed
            if (issues.length === 0) {
                log('‚úì Basic collection existence validation passed', 's');
                return true;
            } else {
                log(`Found ${issues.length} issues in basic validation`, 'w');
                return false;
            }
        } catch (error) {
            log(`Validation failed: ${error.message}`, 'e');
            return false;
        }
    }


    runFullSetupButton.onclick = async () => {
        runFullSetupButton.disabled = true; runSchemaOnlyButton.disabled = true; runSeedOnlyButton.disabled = true;
        outputDiv.innerHTML = ''; log('=== FULL SETUP PROCESS STARTED ===', 'i');
        const pb = new PocketBase(pbUrl);
        try {
            log("Step 1: Setting up schema (collections without relations, then relations, then rules)...", 'i');
            const schemaSuccess = await safeExecute(async () => setupSchema(pb), "Schema Setup", pb);
            if (!schemaSuccess.success) { log('Schema setup failed, aborting full setup', 'e'); return; }

            log("Step 2: Seeding data...", 'i');
            const seedSuccess = await safeExecute(async () => setupSeedData(pb), "Seed Data Setup", pb);
            if (!seedSuccess.success) { log('Seed data setup failed', 'e'); return; }
            
            log("Step 3: Validating final setup...", 'i');
            await safeExecute(async () => validateSetup(pb), "Final Validation", pb);
            
            validateProductionSecurity();
            log('<b>=== FULL SETUP PROCESS COMPLETED ===</b>', 's');
            runSeedOnlyButton.disabled = false;
        } catch (error) { // This catch is for unexpected errors not caught by safeExecute
            log(`<b>CRITICAL UNHANDLED ERROR during full setup:</b> ${error.message}`, 'e');
        } finally {
            if (pb.authStore.isValid) { pb.authStore.clear(); log('Admin auth cleared.', 'd'); }
            runFullSetupButton.disabled = false; runSchemaOnlyButton.disabled = false;
            log('Process finished.', 'i');
        }
    };

    runSchemaOnlyButton.onclick = async () => {
        runFullSetupButton.disabled = true; runSchemaOnlyButton.disabled = true; runSeedOnlyButton.disabled = true;
        outputDiv.innerHTML = ''; log('=== SCHEMA ONLY SETUP STARTED ===', 'i');
        const pb = new PocketBase(pbUrl);
        try {
            const schemaResult = await safeExecute(async () => setupSchema(pb), "Schema Setup", pb);
            if (schemaResult.success) {
                runSeedOnlyButton.disabled = false;
                log('<b>Schema setup completed successfully</b>', 's');
                await safeExecute(async () => validateSetup(pb), "Post-Schema Validation", pb);
                validateProductionSecurity();
            }
        } finally {
            if (pb.authStore.isValid) { pb.authStore.clear(); log('Admin auth cleared.', 'd');}
            runFullSetupButton.disabled = false; runSchemaOnlyButton.disabled = false;
        }
    };

    runSeedOnlyButton.onclick = async () => {
        runFullSetupButton.disabled = true; runSchemaOnlyButton.disabled = true; runSeedOnlyButton.disabled = true;
        outputDiv.innerHTML = ''; log('=== SEED DATA ONLY STARTED ===', 'i');
        const pb = new PocketBase(pbUrl);
        try {
            const seedResult = await safeExecute(async () => setupSeedData(pb), "Seed Data Setup", pb);
             if (seedResult.success) {
                log('<b>Seed data setup completed successfully</b>', 's');
                await safeExecute(async () => validateSetup(pb), "Post-Seed Validation", pb);
            }
        } finally {
            if (pb.authStore.isValid) { pb.authStore.clear(); log('Admin auth cleared.', 'd');}
            runFullSetupButton.disabled = false; runSchemaOnlyButton.disabled = false; runSeedOnlyButton.disabled = false;
        }
    };
    
    // Added safeExecute wrapper for general operations
    async function safeExecute(operation, operationName, pbInstanceForAuthClear = null) {
        try {
            log(`Starting ${operationName}...`, 'i');
            const result = await operation(); // Operation should return true/false or data
            // Check if operation returned an object with success property, or just a truthy/falsy value
            const success = (typeof result === 'object' && result !== null && 'success' in result) ? result.success : !!result;
            if (success) {
                log(`${operationName} completed successfully.`, 's');
            } else {
                log(`${operationName} reported failure.`, 'w', result); // Log result if it's an object with details
            }
            return { success, result };
        } catch (error) {
            log(`${operationName} failed with exception: ${error.message}`, 'e');
            console.error(`${operationName} error:`, error);
            if (error.response?.data) log(`${operationName} server error:`, 'e', error.response.data);
            if (error.stack) log(`${operationName} stack trace:`, 'e', error.stack);
            if (error.url) log(`Failed URL: ${error.url}`, 'e');
            if (error.status) log(`HTTP Status: ${error.status}`, 'e');
            return { success: false, error };
        } finally {
            // Only clear auth if pbInstanceForAuthClear is provided and auth is valid
            if (pbInstanceForAuthClear && pbInstanceForAuthClear.authStore.isValid) {
                 // Decided against clearing auth here, let the calling function manage it in its own finally.
                 // pbInstanceForAuthClear.authStore.clear(); 
                 // log(`Auth cleared after ${operationName}`, 'd');
            }
        }
    }
</script>
</body>
</html>
