<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PB Setup: SheepLand Udheya - Farm Management</title>
    <script src="https://unpkg.com/pocketbase@latest/dist/pocketbase.umd.js"></script>
    <style>
        body{font-family:sans-serif;font-size:13px;line-height:1.4;padding:10px;background:#f0f0f0;color:#333;display:flex;flex-direction:column;align-items:center;margin:0;}
        .c{max-width:700px;width:100%;background:white;padding:15px;border-radius:5px;box-shadow:0 2px 8px rgba(0,0,0,0.1);}
        h1{color:#333;border-bottom:1px solid #ccc;padding-bottom:5px;margin:0 0 10px 0;font-size:1.2em;}
        p{font-size:0.9em;margin:0 0 0.5em 0;} .warn{color:red;font-weight:bold;}
        button{padding:6px 10px;background:#007bff;color:white;border:0;border-radius:3px;cursor:pointer;font-size:0.85em;margin-bottom:5px;}
        button:disabled{background:#ccc;} button:hover:not(:disabled){background:#0056b3;}
        #out{margin-top:10px;padding:8px;background:#222;color:#eee;border-radius:3px;white-space:pre-wrap;font-family:monospace;font-size:11px;max-height:70vh;overflow-y:auto;}
        .ls{color:lime;font-weight:bold;} .le{color:salmon;font-weight:bold;} .li{color:cyan;} .lw{color:yellow;} .ld{color:gray;}
    </style>
</head>
<body>
    <div class="c">
        <h1>PB SheepLand Udheya Setup - Farm Management</h1>
        <p class="warn">WARNING: This script uses default admin credentials (admin@example.com / unifiedpassword). CHANGE THESE IMMEDIATELY in a production environment. This script will create/update collections and data. Backup your existing data if necessary.</p>
        <button id="runFullSetup">Run Full Setup</button>
        <button id="runSchemaOnly">Schema Only</button>
        <button id="runSeedOnly" disabled>Seed Data Only</button>
        <button id="debugCollections">Debug Collections Schema</button>
        <div id="out"></div>
    </div>
<script>
    const pbUrl = '/';
    const outputDiv = document.getElementById('out');
    const runFullSetupButton = document.getElementById('runFullSetup');
    const runSchemaOnlyButton = document.getElementById('runSchemaOnly');
    const runSeedOnlyButton = document.getElementById('runSeedOnly');
    const debugCollectionsButton = document.getElementById('debugCollections');
    const ADM_E = 'admin@example.com';
    const ADM_P = 'unifiedpassword';

    const log = (message, type = 'i', data = null) => {
        const timestamp = `[${new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' })}] `;
        const p = document.createElement('p');
        p.className = `l${type[0]}`;
        let logMessage = timestamp + message.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        if (data) {
            logMessage += `\n<pre class="ld">${JSON.stringify(data, null, 2).replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>`;
        }
        p.innerHTML = logMessage;
        outputDiv.appendChild(p);
        outputDiv.scrollTop = outputDiv.scrollHeight;
        const consoleMessage = timestamp + message.replace(/<[^>]*>?/gm, '');
        if (type === 'e') console.error(consoleMessage, data || '');
        else if (type === 'w') console.warn(consoleMessage, data || '');
        else if (type === 'd') console.debug(consoleMessage, data || '');
        else console.log(consoleMessage, data || '');
    };

    const collectionsDefinition = [
        {
            name: "settings", 
            type: "base", 
            listRule: "", 
            viewRule: "", 
            createRule: null, 
            updateRule: "@request.auth.id != ''", 
            deleteRule: null,
            fields: [
                { name: "xchgRates", type: "json", required: true, presentable: true }, 
                { name: "defCurr", type: "text", required: true, presentable: true, max: 5 },
                { name: "waNumRaw", type: "text", required: false, presentable: true }, 
                { name: "waNumDisp", type: "text", required: false, presentable: true },
                { name: "promoEndISO", type: "date", required: false, presentable: true }, 
                { name: "promoDiscPc", type: "number", required: false, presentable: true, min: 0, max: 100 },
                { name: "promoActive", type: "bool", required: false, presentable: true }, 
                { name: "servFeeEGP", type: "number", required: true, presentable: true, min: 0 },
                { name: "delAreas", type: "json", required: false, presentable: true }, 
                { name: "payDetails", type: "json", required: false, presentable: true }
            ]
        },
        {
            name: "products", 
            type: "base", 
            listRule: "", 
            viewRule: "", 
            createRule: "@request.auth.id != ''", 
            updateRule: "@request.auth.id != ''", 
            deleteRule: "@request.auth.id != ''",
            fields: [
                { name: "item_key", type: "text", required: true, presentable: true, max: 100, pattern: "^[a-z0-9_]+$" }, 
                { name: "type_key", type: "text", required: true, presentable: true, max: 50, pattern: "^[a-z0-9_]+$" },
                { name: "type_name_en", type: "text", required: true, presentable: true, max: 100 }, 
                { name: "type_name_ar", type: "text", required: true, presentable: true, max: 100 },
                { name: "type_description_en", type: "text", required: false, presentable: true, max: 200 }, 
                { name: "type_description_ar", type: "text", required: false, presentable: true, max: 200 },
                { name: "price_per_kg_egp", type: "number", required: true, presentable: true, min: 0 }, 
                { name: "variant_name_en", type: "text", required: true, presentable: true, max: 150 },
                { name: "variant_name_ar", type: "text", required: true, presentable: true, max: 150 }, 
                { name: "weight_range_text_en", type: "text", required: true, presentable: true, max: 50 },
                { name: "weight_range_text_ar", type: "text", required: true, presentable: true, max: 50 }, 
                { name: "avg_weight_kg", type: "number", required: true, presentable: true, min: 0 },
                { name: "base_price_egp", type: "number", required: true, presentable: true, min: 0 }, 
                { name: "stock_available_pb", type: "number", required: true, presentable: true, min: 0, noDecimal: true },
                { name: "is_active", type: "bool", required: false, presentable: true }, 
                { name: "sort_order_type", type: "number", required: false, presentable: true, min: 0, noDecimal: true },
                { name: "sort_order_variant", type: "number", required: false, presentable: true, min: 0, noDecimal: true }
            ],
            indexes: [ "CREATE UNIQUE INDEX `idx_products_item_key` ON `products` (`item_key`)" ]
        },
        {
            name: "sheep_log", 
            type: "base", 
            listRule: "@request.auth.id != ''", 
            viewRule: "@request.auth.id != ''", 
            createRule: "@request.auth.id != ''", 
            updateRule: "@request.auth.id != ''", 
            deleteRule: "@request.auth.id != ''",
            fields: [
                { name: "animal_tag_id", type: "text", required: true, presentable: true, max: 50, pattern: "^[a-zA-Z0-9_-]+$" },
                { name: "species", type: "text", required: true, presentable: true, max: 50 },
                { name: "breed", type: "text", required: false, presentable: true, max: 100 },
                { name: "date_of_birth", type: "date", required: false, presentable: true },
                { name: "acquisition_date", type: "date", required: true, presentable: true },
                { name: "acquisition_cost_egp", type: "number", required: false, presentable: true, min: 0 },
                { name: "source", type: "text", required: false, presentable: true, max: 150 },
                { name: "gender", type: "select", required: false, presentable: true, maxSelect: 1, values: ["Male", "Female", "Unknown"] },
                { name: "initial_weight_kg", type: "number", required: false, presentable: true, min: 0 },
                { name: "current_status", type: "select", required: true, presentable: true, maxSelect: 1, values: ["Active", "Sold", "Deceased", "Culled", "Quarantined"] },
                { name: "notes", type: "text", required: false, presentable: true, max: 1000 },
                { name: "product_item_key_association", type: "text", required: false, presentable: true, max: 100 }
            ],
            indexes: [ "CREATE UNIQUE INDEX `idx_sheep_log_animal_tag_id` ON `sheep_log` (`animal_tag_id`)" ]
        },
        {
            name: "animal_events", 
            type: "base", 
            listRule: "@request.auth.id != ''", 
            viewRule: "@request.auth.id != ''", 
            createRule: "@request.auth.id != ''", 
            updateRule: "@request.auth.id != ''", 
            deleteRule: "@request.auth.id != ''",
            fields: [
                { name: "event_date", type: "date", required: true, presentable: true },
                { name: "event_type", type: "select", required: true, presentable: true, maxSelect: 1, values: ["Vaccination", "Medication", "Feeding Change", "Weight Check", "Breeding", "Birth (Offspring)", "Injury", "Illness", "Relocation", "Status Change", "Other"] },
                { name: "description", type: "text", required: true, presentable: true, max: 500 },
                { name: "cost_associated_egp", type: "number", required: false, presentable: true, min: 0 },
                { name: "vet_involved", type: "text", required: false, presentable: true, max: 100 },
                { name: "medication_details", type: "text", required: false, presentable: true, max: 200 },
                { name: "weight_kg_at_event", type: "number", required: false, presentable: true, min: 0 },
                { name: "notes", type: "text", required: false, presentable: true, max: 1000 }
            ],
            indexes: [ "CREATE INDEX `idx_animal_events_event_date` ON `animal_events` (`event_date`)" ]
        },
        {
            name: "orders", 
            type: "base", 
            listRule: "", 
            viewRule: "", 
            createRule: "", 
            updateRule: null, 
            deleteRule: null,
            fields: [
                { name: "order_id_text", type: "text", required: true, presentable: true, max: 50 },
                { name: "ordered_product_name_en", type: "text", required: false, presentable: true, max: 150 }, 
                { name: "ordered_product_name_ar", type: "text", required: false, presentable: true, max: 150 },
                { name: "ordered_weight_range_en", type: "text", required: false, presentable: true, max: 50 }, 
                { name: "ordered_weight_range_ar", type: "text", required: false, presentable: true, max: 50 },
                { name: "price_at_order_time_egp", type: "number", required: true, presentable: true, min: 0 }, 
                { name: "cost_of_animal_egp", type: "number", required: false, presentable: false, min: 0 },
                { name: "udheya_service_option_selected", type: "text", required: true, presentable: true, max: 50 }, 
                { name: "service_fee_applied_egp", type: "number", required: true, presentable: true, min: 0 },
                { name: "delivery_fee_applied_egp", type: "number", required: false, presentable: true, min: 0 }, 
                { name: "total_amount_due_egp", type: "number", required: true, presentable: true, min: 0 },
                { name: "selected_display_currency", type: "text", required: false, presentable: true, max: 5 }, 
                { name: "sacrifice_day_value", type: "text", required: true, presentable: true, max: 50 },
                { name: "sacrifice_day_text_en", type: "text", required: false, presentable: true, max: 100 }, 
                { name: "sacrifice_day_text_ar", type: "text", required: false, presentable: true, max: 100 },
                { name: "slaughter_viewing_preference", type: "text", required: false, presentable: true, max: 50 }, 
                { name: "distribution_choice", type: "text", required: false, presentable: true, max: 50 },
                { name: "split_details_option", type: "text", required: false, presentable: true, max: 100 }, 
                { name: "custom_split_details_text", type: "text", required: false, presentable: true, max: 500 },
                { name: "niyyah_names", type: "text", required: false, presentable: true, max: 500 }, 
                { name: "ordering_person_name", type: "text", required: true, presentable: true, max: 150 },
                { name: "ordering_person_phone", type: "text", required: true, presentable: true, max: 30 }, 
                { name: "customer_email", type: "email", required: false, presentable: true },
                { name: "delivery_option", type: "text", required: false, presentable: true, max: 50 }, 
                { name: "delivery_name", type: "text", required: false, presentable: true, max: 150 },
                { name: "delivery_phone", type: "text", required: false, presentable: true, max: 30 }, 
                { name: "delivery_area_id", type: "text", required: false, presentable: true, max: 50 },
                { name: "delivery_area_name_en", type: "text", required: false, presentable: true, max: 100 }, 
                { name: "delivery_area_name_ar", type: "text", required: false, presentable: true, max: 100 },
                { name: "delivery_address", type: "text", required: false, presentable: true, max: 500 }, 
                { name: "delivery_instructions", type: "text", required: false, presentable: true, max: 500 },
                { name: "time_slot", type: "text", required: false, presentable: true, max: 50 }, 
                { name: "payment_method", type: "text", required: true, presentable: true, max: 50 },
                { name: "payment_status", type: "select", required: true, presentable: true, maxSelect: 1, values: ["pending_payment", "payment_under_review", "paid_confirmed", "cod_pending_confirmation", "cod_confirmed_pending_delivery", "failed", "refunded"] },
                { name: "order_status", type: "select", required: true, presentable: true, maxSelect: 1, values: ["confirmed_pending_payment", "payment_confirmed_processing", "ready_for_fulfillment", "fulfilled_completed", "cancelled_by_user", "cancelled_by_admin"] },
                { name: "terms_agreed", type: "bool", required: false, presentable: true }, 
                { name: "admin_notes", type: "text", required: false, presentable: false, max: 1000 },
                { name: "group_purchase_interest", type: "bool", required: false, presentable: true }, 
                { name: "user_ip_address", type: "text", required: false, presentable: false, max: 50 },
                { name: "user_agent_string", type: "text", required: false, presentable: false, max: 300 }
            ],
            indexes: [ "CREATE UNIQUE INDEX `idx_orders_order_id_text` ON `orders` (`order_id_text`)" ]
        },
        {
            name: "expenses", 
            type: "base", 
            listRule: "@request.auth.id != ''", 
            viewRule: "@request.auth.id != ''", 
            createRule: "@request.auth.id != ''", 
            updateRule: "@request.auth.id != ''", 
            deleteRule: "@request.auth.id != ''",
            fields: [
                { name: "expense_date", type: "date", required: true, presentable: true }, 
                { name: "category", type: "text", required: true, presentable: true, max: 100 },
                { name: "description", type: "text", required: true, presentable: true, max: 500 }, 
                { name: "amount_egp", type: "number", required: true, presentable: true, min: 0 },
                { name: "vendor", type: "text", required: false, presentable: true, max: 150 }, 
                { name: "payment_method", type: "text", required: false, presentable: true, max: 50 },
                { name: "receipt", type: "file", required: false, presentable: true, maxSelect: 1, maxSize: 5242880, mimeTypes: ["image/jpeg", "image/png", "application/pdf"] },
                { name: "notes", type: "text", required: false, presentable: true, max: 1000 }
            ],
            indexes: [ 
                "CREATE INDEX `idx_expenses_date` ON `expenses` (`expense_date`)", 
                "CREATE INDEX `idx_expenses_category` ON `expenses` (`category`)" 
            ]
        }
    ];

    const seedData = {
        settings: [
            {
                xchgRates: { 
                    EGP: { rate_from_egp: 1, symbol: "LE", is_active: true }, 
                    USD: { rate_from_egp: 0.020, symbol: "$", is_active: true }, 
                    GBP: { rate_from_egp: 0.015, symbol: "£", is_active: true } 
                },
                defCurr: "EGP", 
                waNumRaw: "201117117489", 
                waNumDisp: "+20 11 1711 7489", 
                promoEndISO: "2025-06-07", 
                promoDiscPc: 10, 
                promoActive: true, 
                servFeeEGP: 750,
                delAreas: [ 
                    { 
                        id: "giza_west", 
                        name_en: "Giza West", 
                        name_ar: "غرب الجيزة", 
                        cities: [ 
                            { id: "october", name_en: "6th of October City", name_ar: "مدينة 6 أكتوبر", delivery_fee_egp: 150 }, 
                            { id: "zayed", name_en: "Sheikh Zayed", name_ar: "الشيخ زايد", delivery_fee_egp: 150 }, 
                            { id: "euro_reef", name_en: "European Reef", name_ar: "الريف الأوروبى", delivery_fee_egp: 150 } 
                        ] 
                    }, 
                    { 
                        id:"cairo", 
                        name_en:"Cairo", 
                        name_ar:"القاهرة", 
                        cities:[ 
                            {id:"nasr_city", name_en:"Nasr City", name_ar:"مدينة نصر", delivery_fee_egp: 250 }, 
                            {id:"maadi", name_en:"Maadi", name_ar:"المعادي", delivery_fee_egp: 250 }, 
                            {id:"heliopolis", name_en:"Heliopolis", name_ar:"مصر الجديدة", delivery_fee_egp: 250} 
                        ] 
                    } 
                ],
                payDetails: { 
                    vodafone_cash: "01076543210", 
                    instapay_ipn: "seed_user@instapay", 
                    revolut_details: "@seedUserRevolut", 
                    monzo_details: "monzo.me/seeduser", 
                    bank_name: "Seed Bank Egypt", 
                    bank_account_name: "Sheep Land Seed Account", 
                    bank_account_number: "1234567890123456", 
                    bank_iban: "EG00123400000000001234567890", 
                    bank_swift: "SEEDBANKEGCA" 
                }
            }
        ],
        products: [
            { item_key: "baladi_40_50", type_key: "baladi", type_name_en: "Baladi Sheep", type_name_ar: "خروف بلدي", type_description_en: "Local breed, rich flavor.", type_description_ar: "سلالة محلية، نكهة غنية.", price_per_kg_egp: 230, variant_name_en: "Baladi (40-50kg)", variant_name_ar: "بلدي (٤٠-٥٠كجم)", weight_range_text_en: "40-50kg", weight_range_text_ar: "٤٠-٥٠ كجم", avg_weight_kg: 45, base_price_egp: 10350, stock_available_pb: 7, is_active: true, sort_order_type: 1, sort_order_variant: 1 },
            { item_key: "baladi_50_60", type_key: "baladi", type_name_en: "Baladi Sheep", type_name_ar: "خروف بلدي", type_description_en: "Local breed, rich flavor.", type_description_ar: "سلالة محلية، نكهة غنية.", price_per_kg_egp: 230, variant_name_en: "Baladi (50-60kg)", variant_name_ar: "بلدي (٥٠-٦٠كجم)", weight_range_text_en: "50-60kg", weight_range_text_ar: "٥٠-٦٠ كجم", avg_weight_kg: 55, base_price_egp: 12650, stock_available_pb: 8, is_active: true, sort_order_type: 1, sort_order_variant: 2 },
            { item_key: "baladi_60_plus", type_key: "baladi", type_name_en: "Baladi Sheep", type_name_ar: "خروف بلدي", type_description_en: "Local breed, rich flavor.", type_description_ar: "سلالة محلية، نكهة غنية.", price_per_kg_egp: 230, variant_name_en: "Baladi (60+kg)", variant_name_ar: "بلدي (+٦٠كجم)", weight_range_text_en: "60+kg", weight_range_text_ar: "+٦٠ كجم", avg_weight_kg: 65, base_price_egp: 14950, stock_available_pb: 1, is_active: true, sort_order_type: 1, sort_order_variant: 3 },
            { item_key: "barki_30_40", type_key: "barki", type_name_en: "Barki Sheep", type_name_ar: "خروف برقي", type_description_en: "Desert breed, lean meat.", type_description_ar: "سلالة صحراوية، لحم قليل الدهن.", price_per_kg_egp: 255, variant_name_en: "Barki (30-40kg)", variant_name_ar: "برقي (٣٠-٤٠كجم)", weight_range_text_en: "30-40kg", weight_range_text_ar: "٣٠-٤٠ كجم", avg_weight_kg: 35, base_price_egp: 8925, stock_available_pb: 1, is_active: true, sort_order_type: 2, sort_order_variant: 1 },
            { item_key: "barki_40_50", type_key: "barki", type_name_en: "Barki Sheep", type_name_ar: "خروف برقي", type_description_en: "Desert breed, lean meat.", type_description_ar: "سلالة صحراوية، لحم قليل الدهن.", price_per_kg_egp: 255, variant_name_en: "Barki (40-50kg)", variant_name_ar: "برقي (٤٠-٥٠كجم)", weight_range_text_en: "40-50kg", weight_range_text_ar: "٤٠-٥٠ كجم", avg_weight_kg: 45, base_price_egp: 11475, stock_available_pb: 5, is_active: true, sort_order_type: 2, sort_order_variant: 2 },
            { item_key: "barki_50_60", type_key: "barki", type_name_en: "Barki Sheep", type_name_ar: "خروف برقي", type_description_en: "Desert breed, lean meat.", type_description_ar: "سلالة صحراوية، لحم قليل الدهن.", price_per_kg_egp: 255, variant_name_en: "Barki (50-60kg)", variant_name_ar: "برقي (٥٠-٦٠كجم)", weight_range_text_en: "50-60kg", weight_range_text_ar: "٥٠-٦٠ كجم", avg_weight_kg: 55, base_price_egp: 14025, stock_available_pb: 3, is_active: true, sort_order_type: 2, sort_order_variant: 3 },
            { item_key: "barki_60_plus", type_key: "barki", type_name_en: "Barki Sheep", type_name_ar: "خروف برقي", type_description_en: "Desert breed, lean meat.", type_description_ar: "سلالة صحراوية، لحم قليل الدهن.", price_per_kg_egp: 255, variant_name_en: "Barki (60+kg)", variant_name_ar: "برقي (+٦٠كجم)", weight_range_text_en: "60+kg", weight_range_text_ar: "+٦٠ كجم", avg_weight_kg: 65, base_price_egp: 16575, stock_available_pb: 2, is_active: true, sort_order_type: 2, sort_order_variant: 4 }
        ],
        sheep_log: [
            { animal_tag_id: "SL-B-001", species: "Sheep", breed: "Baladi", acquisition_date: new Date(new Date().setDate(new Date().getDate()-60)).toISOString().split('T')[0], acquisition_cost_egp: 6500, source: "Farm Born", gender: "Male", initial_weight_kg: 15, current_status: "Active", product_item_key_association: "baladi_50_60"},
            { animal_tag_id: "SL-B-002", species: "Sheep", breed: "Baladi", acquisition_date: new Date(new Date().setDate(new Date().getDate()-60)).toISOString().split('T')[0], acquisition_cost_egp: 6800, source: "Al-Amin Market", gender: "Male", initial_weight_kg: 18, current_status: "Active", product_item_key_association: "baladi_60_plus"},
            { animal_tag_id: "SL-K-001", species: "Sheep", breed: "Barki", acquisition_date: new Date(new Date().setDate(new Date().getDate()-45)).toISOString().split('T')[0], acquisition_cost_egp: 5500, source: "Supplier Z", gender: "Female", initial_weight_kg: 12, current_status: "Active", product_item_key_association: "barki_40_50"}
        ],
        animal_events: [
            { animal_tag_id_for_seed: "SL-B-001", event_date: new Date(new Date().setDate(new Date().getDate()-30)).toISOString().split('T')[0], event_type: "Vaccination", description: "Annual booster shots", cost_associated_egp: 50},
            { animal_tag_id_for_seed: "SL-B-001", event_date: new Date(new Date().setDate(new Date().getDate()-5)).toISOString().split('T')[0], event_type: "Weight Check", description: "Routine weight check", weight_kg_at_event: 48},
            { animal_tag_id_for_seed: "SL-K-001", event_date: new Date(new Date().setDate(new Date().getDate()-20)).toISOString().split('T')[0], event_type: "Medication", description: "Deworming", cost_associated_egp: 75, medication_details: "Ivermectin Oral Solution"}
        ],
        expenses: [
            { expense_date: new Date(new Date().setDate(new Date().getDate()-15)).toISOString().split('T')[0], category: "Animal Feed", description: "Initial stock of hay and grains", amount_egp: 5000, vendor: "Al-Baraka Feeds", payment_method: "Bank Transfer"},
            { expense_date: new Date(new Date().setDate(new Date().getDate()-10)).toISOString().split('T')[0], category: "Vet Services", description: "Health checkup for new arrivals", amount_egp: 1200, vendor: "Dr. Saleh Vet Clinic", payment_method: "Cash"},
            { expense_date: new Date(new Date().setDate(new Date().getDate()-5)).toISOString().split('T')[0], category: "Marketing", description: "Social media ad boost", amount_egp: 300, payment_method: "Credit Card"}
        ]
    };

    async function authenticateAdmin(pb) {
        try {
            log(`Attempting admin authentication with: ${ADM_E}...`, 'i');
            await pb.admins.authWithPassword(ADM_E, ADM_P);
            log('Admin authentication successful', 's');
            return true;
        } catch (error) {
            log(`Authentication failed: ${error.message}`, 'e', error.response?.data || error);
            return false;
        }
    }

    async function createOrUpdateCollection(pb, collectionData) {
        try {
            let existingCollection = null;
            try {
                existingCollection = await pb.collections.getOne(collectionData.name);
            } catch (_) { /* collection doesn't exist */ }

            if (existingCollection) {
                log(`Collection ${collectionData.name} exists. Updating...`, 'w');
                await pb.collections.update(existingCollection.id, {
                    fields: collectionData.fields,
                    listRule: collectionData.listRule,
                    viewRule: collectionData.viewRule,
                    createRule: collectionData.createRule,
                    updateRule: collectionData.updateRule,
                    deleteRule: collectionData.deleteRule
                });
                log(`Collection ${collectionData.name} updated successfully.`, 's');
            } else {
                log(`Creating collection: ${collectionData.name}`, 'i');
                await pb.collections.create(collectionData);
                log(`Collection ${collectionData.name} created successfully.`, 's');
            }
        } catch (error) {
            log(`Failed to create/update collection ${collectionData.name}: ${error.message}`, 'e', error.response?.data || error);
            throw error;
        }
    }

    async function setupCollections(pb, collectionsToSetup) {
        log('Processing collections...', 'i');
        for (const collectionDef of collectionsToSetup) {
            await createOrUpdateCollection(pb, collectionDef);
        }
        log('All collections processed.', 's');
    }

    async function addRelationField(pb, collectionName, fieldName, targetCollectionName, isRequired = true, displayFields = ["id"]) {
        try {
            log(`Checking/Adding relation field ${fieldName} to ${collectionName} targeting ${targetCollectionName}...`, 'i');
            const collection = await pb.collections.getOne(collectionName);
            const targetCollection = await pb.collections.getOne(targetCollectionName);

            const fieldExists = collection.fields.some(f => f.name === fieldName);
            if (fieldExists) {
                log(`Field ${fieldName} already exists in ${collectionName}, skipping.`, 'w');
                return true;
            }

            const newRelationField = {
                name: fieldName, 
                type: "relation", 
                required: isRequired, 
                presentable: true,
                collectionId: targetCollection.id, 
                cascadeDelete: false, 
                minSelect: isRequired ? 1 : null, 
                maxSelect: 1, 
                displayFields: displayFields
            };

            const updatedFields = [...collection.fields, newRelationField];
            await pb.collections.update(collection.id, { fields: updatedFields });
            log(`Relation field ${fieldName} added to ${collectionName} successfully.`, 's');
            return true;
        } catch (error) {
            log(`ERROR adding relation field ${fieldName} to ${collectionName}: ${error.message}`, 'e', error.response?.data || error);
            return false;
        }
    }

    async function seedCollectionData(pb, collectionName, seedItems, uniqueKeyField = null) {
        log(`Seeding data for ${collectionName}...`, 'i');
        let createdCount = 0, updatedCount = 0, errorCount = 0;
        
        for (const item of seedItems) {
            try {
                let existingRecord = null;
                if (uniqueKeyField && item[uniqueKeyField] !== undefined) {
                    try { 
                        existingRecord = await pb.collection(collectionName).getFirstListItem(`${uniqueKeyField}="${item[uniqueKeyField]}"`); 
                    } catch (e) { /* Record not found */ }
                } else if (!uniqueKeyField && collectionName === "settings") { 
                    const list = await pb.collection(collectionName).getList(1, 1);
                    if (list.items.length > 0) existingRecord = list.items[0];
                }

                if (existingRecord) {
                    log(`Updating existing record in ${collectionName} (ID: ${existingRecord.id})`, 'd');
                    await pb.collection(collectionName).update(existingRecord.id, item);
                    updatedCount++;
                } else {
                    log(`Creating new record in ${collectionName}`, 'd');
                    await pb.collection(collectionName).create(item);
                    createdCount++;
                }
            } catch (error) {
                log(`Error processing item in ${collectionName}: ${error.message}`, 'e', error.response?.data || error);
                errorCount++;
            }
        }
        log(`Seeding ${collectionName} complete. Created: ${createdCount}, Updated: ${updatedCount}, Errors: ${errorCount}`, errorCount > 0 ? 'w' : 's');
    }

    async function updateCollectionRules(pb, collectionName, rules) {
        try {
            log(`Updating rules for collection ${collectionName}...`, 'i');
            const collection = await pb.collections.getOne(collectionName);
            await pb.collections.update(collection.id, rules); 
            log(`Rules for ${collectionName} updated successfully.`, 's');
            return true;
        } catch (error) {
            log(`ERROR updating rules for ${collectionName}: ${error.message}`, 'e', error.response?.data || error);
            return false;
        }
    }

    async function debugCollectionSchema(pb, collectionName) {
        try {
            const collection = await pb.collections.getOne(collectionName);
            log(`=== DEBUG: ${collectionName} Collection Schema ===`, 'i');
            log(`Collection ID: ${collection.id}`, 'd');
            log(`Fields (${collection.fields.length}):`, 'd');
            collection.fields.forEach((field, index) => {
                log(`  ${index + 1}. ${field.name} (${field.type})${field.type === 'relation' ? ` -> ${field.collectionId}` : ''}`, 'd');
            });
            log(`Rules:`, 'd', {
                listRule: collection.listRule,
                viewRule: collection.viewRule,
                createRule: collection.createRule,
                updateRule: collection.updateRule,
                deleteRule: collection.deleteRule
            });
        } catch (error) {
            log(`Error debugging ${collectionName}: ${error.message}`, 'e');
        }
    }

    async function setupSchema(pb) {
        log('=== SCHEMA SETUP PHASE ===', 'i');
        if (!await authenticateAdmin(pb)) return false;
        
        await setupCollections(pb, collectionsDefinition);

        log('Step 2: Adding relation fields...', 'i');
        if (!await addRelationField(pb, 'orders', 'user', 'users', false, ["username", "email"])) return false;
        if (!await addRelationField(pb, 'orders', 'product_id', 'products', true, ["item_key", "variant_name_en"])) return false;
        if (!await addRelationField(pb, 'orders', 'animal_id', 'sheep_log', false, ["animal_tag_id"])) return false;
        if (!await addRelationField(pb, 'animal_events', 'animal_id', 'sheep_log', true, ["animal_tag_id"])) return false;
        
        log('Step 3: Updating API rules for "orders" collection...', 'i');
        const finalOrdersRules = {
            listRule: "user = @request.auth.id || ordering_person_phone = @request.query.lookupPhone:string",
            viewRule: "user = @request.auth.id || ordering_person_phone = @request.query.lookupPhone:string",
            createRule: "@request.auth.id != '' || ordering_person_phone != ''",
            updateRule: "user = @request.auth.id",
            deleteRule: null
        };
        if (!await updateCollectionRules(pb, 'orders', finalOrdersRules)) return false;

        log('Schema setup completed successfully.', 's');
        return true;
    }

    async function setupSeedData(pb) {
        log('=== SEED DATA PHASE ===', 'i');
        if (!await authenticateAdmin(pb)) return false;
        log('Pausing for 1 second before seeding...', 'i');
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        await seedCollectionData(pb, 'settings', seedData.settings); 
        await seedCollectionData(pb, 'products', seedData.products, 'item_key');
        await seedCollectionData(pb, 'sheep_log', seedData.sheep_log, 'animal_tag_id');
        
        log('Seeding animal_events (linking to sheep_log)...', 'i');
        for (const eventData of seedData.animal_events) {
            try {
                const animal = await pb.collection('sheep_log').getFirstListItem(`animal_tag_id="${eventData.animal_tag_id_for_seed}"`);
                if (animal) {
                    const dataToCreate = {...eventData, animal_id: animal.id};
                    delete dataToCreate.animal_tag_id_for_seed;
                    await pb.collection('animal_events').create(dataToCreate);
                    log(`Created event for animal ${eventData.animal_tag_id_for_seed}`, 'd');
                } else {
                    log(`Could not find animal with tag ${eventData.animal_tag_id_for_seed} for event seeding.`, 'w');
                }
            } catch (error) {
                log(`Error seeding event for ${eventData.animal_tag_id_for_seed}: ${error.message}`, 'e');
            }
        }
        await seedCollectionData(pb, 'expenses', seedData.expenses);
        
        log('Seed data setup completed successfully.', 's');
    }
    
    function validateProductionSecurity() {
        const warnings = [];
        collectionsDefinition.forEach(collection => {
            if (!["settings", "products"].includes(collection.name)) { 
                if (collection.createRule === "") warnings.push(`Collection ${collection.name} initial createRule is public.`);
                if (collection.updateRule === "") warnings.push(`Collection ${collection.name} initial updateRule is public.`);
                if (collection.deleteRule === "") warnings.push(`Collection ${collection.name} initial deleteRule is public.`);
            }
             if (collection.name === "orders" && collection.listRule === "") { 
                 warnings.push(`Collection 'orders' initial listRule is public. Ensure final rules are restrictive.`);
             }
        });
        if (ADM_E === 'admin@example.com' && ADM_P === 'unifiedpassword') {
            warnings.push('Using default admin credentials - CHANGE FOR PRODUCTION');
        }
        if (warnings.length > 0) {
            log('🚨 PRODUCTION SECURITY WARNINGS:', 'e');
            warnings.forEach(warning => log(`⚠️  ${warning}`, 'w'));
            log('🚨 SECURE THESE BEFORE PRODUCTION DEPLOYMENT', 'e');
        }
    }
    
    async function validateSetup(pb) {
        log('Validating setup...', 'i');
        const issues = [];
        if (!await authenticateAdmin(pb)) { 
            issues.push("✗ Admin authentication failed post-setup."); 
        }

        const expectedCollections = ['settings', 'products', 'orders', 'users', 'expenses', 'sheep_log', 'animal_events'];
        let productsCollId = null; 
        let usersCollId = null; 
        let sheepLogCollId = null;

        // First, get all collection IDs
        for (const name of expectedCollections) {
            try {
                const coll = await pb.collections.getOne(name);
                log(`✓ Collection ${name} (ID: ${coll.id}) exists.`, 's');
                if (name === 'products') productsCollId = coll.id;
                if (name === 'users') usersCollId = coll.id;
                if (name === 'sheep_log') sheepLogCollId = coll.id;
            } catch (error) { 
                issues.push(`✗ Collection ${name} missing: ${error.message}`); 
            }
        }

        // Now validate relations with the correct IDs
        try {
            const ordersCollection = await pb.collections.getOne('orders');
            
            const userField = ordersCollection.fields.find(f => f.name === 'user');
            const productField = ordersCollection.fields.find(f => f.name === 'product_id');
            const animalLinkField = ordersCollection.fields.find(f => f.name === 'animal_id');
            
            if (userField?.type === 'relation' && userField.collectionId === usersCollId) {
                log(`✓ Relation 'user' in 'orders' correctly points to users collection.`, 's'); 
            } else {
                issues.push(`✗ Relation 'user' in 'orders' MISCONFIGURED. Found: ${userField ? `${userField.type} -> ${userField.collectionId}` : 'MISSING'}, Expected: relation -> ${usersCollId}`);
            }
            
            if (productField?.type === 'relation' && productField.collectionId === productsCollId) {
                log(`✓ Relation 'product_id' in 'orders' correctly points to products collection.`, 's'); 
            } else {
                issues.push(`✗ Relation 'product_id' in 'orders' MISCONFIGURED. Found: ${productField ? `${productField.type} -> ${productField.collectionId}` : 'MISSING'}, Expected: relation -> ${productsCollId}`);
            }
            
            if (animalLinkField?.type === 'relation' && animalLinkField.collectionId === sheepLogCollId) {
                log(`✓ Relation 'animal_id' in 'orders' correctly points to sheep_log collection.`, 's'); 
            } else {
                issues.push(`✗ Relation 'animal_id' in 'orders' MISCONFIGURED or MISSING. Found: ${animalLinkField ? `${animalLinkField.type} -> ${animalLinkField.collectionId}` : 'MISSING'}, Expected: relation -> ${sheepLogCollId}`);
            }

            const expectedRules = { 
                listRule: "user = @request.auth.id || ordering_person_phone = @request.query.lookupPhone:string", 
                viewRule: "user = @request.auth.id || ordering_person_phone = @request.query.lookupPhone:string", 
                createRule: "@request.auth.id != '' || ordering_person_phone != ''", 
                updateRule: "user = @request.auth.id", 
                deleteRule: null 
            };
            
            for (const ruleKey in expectedRules) { 
                if (ordersCollection[ruleKey] !== expectedRules[ruleKey]) {
                    issues.push(`✗ Rule '${ruleKey}' for 'orders' NOT as expected. Found: "${ordersCollection[ruleKey]}", Expected: "${expectedRules[ruleKey]}"`); 
                } else {
                    log(`✓ Rule '${ruleKey}' for 'orders' is correct.`, 's');
                }
            }
        } catch (error) {
            issues.push(`✗ Error validating orders collection: ${error.message}`);
        }
        
        // Validate animal_events collection
        try {
            const animalEventsCollection = await pb.collections.getOne('animal_events');
            const animalLinkField = animalEventsCollection.fields.find(f => f.name === 'animal_id');
            if (animalLinkField?.type === 'relation' && animalLinkField.collectionId === sheepLogCollId) {
                log(`✓ Relation 'animal_id' in 'animal_events' correctly points to sheep_log collection.`, 's'); 
            } else {
                issues.push(`✗ Relation 'animal_id' in 'animal_events' MISCONFIGURED. Found: ${animalLinkField ? `${animalLinkField.type} -> ${animalLinkField.collectionId}` : 'MISSING'}, Expected: relation -> ${sheepLogCollId}`);
            }
        } catch (error) {
            issues.push(`✗ Error validating animal_events collection: ${error.message}`);
        }
        
        // Validate seed data
        for (const [collectionName, dataToSeed] of Object.entries(seedData)) {
            if (["settings", "products", "expenses", "sheep_log"].includes(collectionName)) { 
                try {
                    const records = await pb.collection(collectionName).getList(1, dataToSeed.length > 0 ? dataToSeed.length : 1);
                    if (records.items.length >= (dataToSeed.length > 0 ? dataToSeed.length : 1) || (collectionName === "settings" && records.items.length > 0) ) {
                        log(`✓ Collection ${collectionName} has data (found ${records.items.length}).`, 's');
                    } else { 
                        issues.push(`✗ Collection ${collectionName} has insufficient seed data.`); 
                    }
                } catch (error) { 
                    issues.push(`✗ Cannot access ${collectionName}: ${error.message}`); 
                }
            }
        }
        
        if (issues.length === 0) { 
            log('✓ All critical validations passed! Your setup is working correctly.', 's'); 
            return true; 
        } else { 
            log(`Found ${issues.length} critical issues during validation.`, 'e'); 
            issues.forEach(issue => log(issue, 'e')); 
            return false; 
        }
    }

    debugCollectionsButton.onclick = async () => {
        outputDiv.innerHTML = '';
        const pb = new PocketBase(pbUrl);
        try {
            if (!await authenticateAdmin(pb)) return;
            
            log('=== DEBUGGING ALL COLLECTIONS ===', 'i');
            const collections = ['settings', 'products', 'orders', 'users', 'expenses', 'sheep_log', 'animal_events'];
            
            for (const collName of collections) {
                await debugCollectionSchema(pb, collName);
            }
            
        } catch (error) {
            log(`Debug error: ${error.message}`, 'e');
        } finally {
            if (pb.authStore.isValid) pb.authStore.clear();
        }
    };

    runFullSetupButton.onclick = async () => {
        runFullSetupButton.disabled = true; 
        runSchemaOnlyButton.disabled = true; 
        runSeedOnlyButton.disabled = true;
        outputDiv.innerHTML = ''; 
        log('=== FULL SETUP PROCESS STARTED ===', 'i');
        const pb = new PocketBase(pbUrl); 
        let schemaSuccess = false;
        
        try {
            schemaSuccess = await setupSchema(pb);
            if (!schemaSuccess) { 
                log('Schema setup failed, aborting full setup.', 'e'); 
                return; 
            }
            await new Promise(resolve => setTimeout(resolve, 500)); 
            await setupSeedData(pb); 
            await new Promise(resolve => setTimeout(resolve, 500)); 
            await validateSetup(pb); 
            validateProductionSecurity();
            log('=== FULL SETUP PROCESS COMPLETED ===', schemaSuccess ? 's' : 'w'); 
            if (schemaSuccess) runSeedOnlyButton.disabled = false;
        } catch (error) {
            log(`CRITICAL ERROR during full setup: ${error.message}`, 'e', error.response?.data || error);
            if (error.stack) log('Stack trace:', 'e', error.stack);
        } finally {
            if (pb.authStore.isValid) pb.authStore.clear();
            runFullSetupButton.disabled = false; 
            runSchemaOnlyButton.disabled = false;
            log('Process finished, auth cleared.', 'i');
        }
    };

    runSchemaOnlyButton.onclick = async () => {
        runFullSetupButton.disabled = true; 
        runSchemaOnlyButton.disabled = true; 
        runSeedOnlyButton.disabled = true;
        outputDiv.innerHTML = ''; 
        const pb = new PocketBase(pbUrl);
        
        try {
            const success = await setupSchema(pb);
            if (success) {
                runSeedOnlyButton.disabled = false; 
                log('Schema setup completed successfully.', 's');
                await validateSetup(pb); 
                validateProductionSecurity();
            } else { 
                log('Schema setup failed.', 'e'); 
            }
        } catch (error) {
            log(`ERROR during schema setup: ${error.message}`, 'e', error.response?.data || error);
        } finally {
            if (pb.authStore.isValid) pb.authStore.clear();
            runFullSetupButton.disabled = false; 
            runSchemaOnlyButton.disabled = false;
        }
    };

    runSeedOnlyButton.onclick = async () => {
        runFullSetupButton.disabled = true; 
        runSchemaOnlyButton.disabled = true; 
        runSeedOnlyButton.disabled = true;
        outputDiv.innerHTML = ''; 
        const pb = new PocketBase(pbUrl);
        
        try {
            await setupSeedData(pb); 
            log('Seed data setup completed successfully.', 's');
            await validateSetup(pb); 
        } catch (error) {
            log(`ERROR during seed setup: ${error.message}`, 'e', error.response?.data || error);
        } finally {
            if (pb.authStore.isValid) pb.authStore.clear();
            runFullSetupButton.disabled = false; 
            runSchemaOnlyButton.disabled = false; 
            runSeedOnlyButton.disabled = false;
        }
    };
</script>
</body>
</html>