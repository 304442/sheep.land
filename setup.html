<!-- Filename: /setup.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PB Setup: Sheep Land</title>
    <script src="https://unpkg.com/pocketbase@latest/dist/pocketbase.umd.js"></script>
    <style>
        body{font-family:sans-serif;font-size:13px;line-height:1.4;padding:10px;background:#f0f0f0;color:#333;display:flex;flex-direction:column;align-items:center;margin:0;}
        .c{max-width:700px;width:100%;background:white;padding:15px;border-radius:5px;box-shadow:0 2px 8px rgba(0,0,0,0.1);}
        h1{color:#333;border-bottom:1px solid #ccc;padding-bottom:5px;margin:0 0 10px 0;font-size:1.2em;}
        p{font-size:0.9em;margin:0 0 0.5em 0;} .warn{color:red;font-weight:bold;}
        button{padding:6px 10px;background:#007bff;color:white;border:0;border-radius:3px;cursor:pointer;font-size:0.85em;margin-bottom:5px;}
        button:disabled{background:#ccc;} button:hover:not(:disabled){background:#0056b3;}
        #out{margin-top:10px;padding:8px;background:#222;color:#eee;border-radius:3px;white-space:pre-wrap;font-family:monospace;font-size:11px;max-height:70vh;overflow-y:auto;}
        .ls{color:lime;font-weight:bold;} /* success */
        .le{color:salmon;font-weight:bold;} /* error */
        .li{color:cyan;} /* info */
        .lw{color:yellow;} /* warning */
        .ld{color:gray;} /* debug / data */
    </style>
</head>
<body>
    <div class="c">
        <h1>PB Sheep Land Setup</h1>
        <p class="warn">WARNING: This script uses default admin credentials (admin@example.com / unifiedpassword). CHANGE THESE IMMEDIATELY in a production environment. This script will create/update collections and data. Backup your existing data if necessary before running.</p>
        <button id="runFullSetup">Run Full Setup</button>
        <button id="runSchemaOnly">Schema Only</button>
        <button id="runSeedOnly" disabled>Seed Data Only</button>
        <div id="out"></div>
    </div>
<script>
    const pbUrl = '/';
    const outputDiv = document.getElementById('out');
    const runFullSetupButton = document.getElementById('runFullSetup');
    const runSchemaOnlyButton = document.getElementById('runSchemaOnly');
    const runSeedOnlyButton = document.getElementById('runSeedOnly');
    const ADM_E = 'admin@example.com';
    const ADM_P = 'unifiedpassword';

    const log = (message, type = 'i', data = null) => {
        const timestamp = `[${new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' })}] `;
        const p = document.createElement('p');
        p.className = `l${type[0].toLowerCase()}`; // Ensure lowercase for class
        let logMessage = timestamp + message.replace(/</g, '<').replace(/>/g, '>');
        if (data) {
            logMessage += `\n<pre class="ld">${JSON.stringify(data, null, 2).replace(/</g, '<').replace(/>/g, '>')}</pre>`;
        }
        p.innerHTML = logMessage;
        outputDiv.appendChild(p);
        outputDiv.scrollTop = outputDiv.scrollHeight;
        
        const consoleMessage = timestamp + message.replace(/<[^>]*>?/gm, ''); // Strip HTML for console
        if (type === 'e') console.error(consoleMessage, data || '');
        else if (type === 'w') console.warn(consoleMessage, data || '');
        else if (type === 'd') console.debug(consoleMessage, data || '');
        else console.log(consoleMessage, data || '');
    };
    
    const defaultRefundPolicyHTMLForSeed = `
        <div class="bil-row">
            <p class="en">Welcome to Sheep Land. We strive to provide the best quality Udheya and livestock services. Please read our policy carefully.</p>
            <p class="ar" dir="rtl">مرحباً بكم في أرض الأغنام. نسعى جاهدين لتقديم أفضل جودة في خدمات الأضاحي والمواشي. يرجى قراءة سياستنا بعناية.</p>
        </div>
        <h3 class="bil-spread modal-section-title">
            <span class="en">Udheya Orders</span><span class="ar" dir="rtl">طلبات الأضاحي</span>
        </h3>
        <div class="bil-row">
            <p class="en">Due to the nature of Udheya (Qurbani/Sacrifice), which is a time-sensitive religious observance, our refund and cancellation policy is as follows:</p>
            <p class="ar" dir="rtl">نظرًا لطبيعة الأضحية، وهي شعيرة دينية مرتبطة بوقت محدد، فإن سياسة الاسترداد والإلغاء لدينا هي كما يلي:</p>
        </div>
        <ul class="modal-list">
            <li><div class="bil-row"><p class="en"><strong>Cancellations Before [Specify Your Cut-off Date/Time, e.g., 3 days before Eid Al-Adha]:</strong> If you wish to cancel your Udheya order before this specified cut-off, you may be eligible for a full refund, minus any transaction fees already incurred by payment processors. Please contact us immediately via WhatsApp or email as provided on our website.</p><p class="ar" dir="rtl"><strong>الإلغاء قبل [حدد تاريخ/وقت القطع الخاص بك، مثلاً، 3 أيام قبل عيد الأضحى]:</strong> إذا كنت ترغب في إلغاء طلب الأضحية الخاص بك قبل هذا الموعد النهائي المحدد، فقد تكون مؤهلاً لاسترداد كامل المبلغ، مخصومًا منه أي رسوم معاملات تكبدتها معالجات الدفع بالفعل. يرجى الاتصال بنا فورًا عبر واتساب أو البريد الإلكتروني كما هو موضح على موقعنا.</p></div></li>
            <li><div class="bil-row"><p class="en"><strong>Cancellations After [Specify Your Cut-off Date/Time]:</strong> Once an animal has been specifically allocated for your Udheya and preparations are underway, or after the specified cut-off date/time, cancellations will generally not be possible, and refunds cannot be guaranteed. This is because the animal is committed on your behalf for the sacrifice. We encourage you to be certain of your order before this deadline.</p><p class="ar" dir="rtl"><strong>الإلغاء بعد [حدد تاريخ/وقت القطع الخاص بك]:</strong> بمجرد تخصيص حيوان معين لأضحيتك وبدء الاستعدادات، أو بعد تاريخ/وقت القطع المحدد، لن يكون الإلغاء ممكنًا بشكل عام، ولا يمكن ضمان المبالغ المستردة. وذلك لأن الحيوان قد تم تخصيصه نيابة عنك للذبح. نشجعك على التأكد من طلبك قبل هذا الموعد النهائي.</p></div></li>
            <li><div class="bil-row"><p class="en"><strong>Non-Fulfilment by Sheep Land:</strong> In the very unlikely event that Sheep Land is unable to fulfil your confirmed and paid Udheya order due to unforeseen circumstances (e.g., illness of an allocated animal with no suitable Sharia-compliant replacement available), a full refund of the amount paid will be issued promptly.</p><p class="ar" dir="rtl"><strong>عدم التنفيذ من قبل أرض الأغنام:</strong> في الحالة غير المحتملة للغاية التي يتعذر فيها على أرض الأغنام تلبية طلب الأضحية المؤكد والمدفوع بسبب ظروف غير متوقعة (مثل مرض الحيوان المخصص مع عدم توفر بديل مناسب متوافق مع الشريعة)، سيتم إصدار استرداد كامل للمبلغ المدفوع على الفور.</p></div></li>
        </ul>
        <h3 class="bil-spread modal-section-title"><span class="en">Other Livestock / Meat Cuts / Gathering Packages</span><span class="ar" dir="rtl">المواشي الأخرى / قطعيات اللحوم / باقات الولائم</span></h3>
        <div class="bil-row"><p class="en">For non-Udheya products:</p><p class="ar" dir="rtl">بالنسبة للمنتجات غير المخصصة للأضاحي:</p></div>
        <ul class="modal-list">
            <li><div class="bil-row"><p class="en"><strong>Cancellations:</strong> Orders can typically be cancelled up to [e.g., 48 hours] before the scheduled delivery/pickup time for a full refund, minus any non-recoverable costs already incurred (e.g., custom cutting for meat orders). Cancellations made with less notice may be subject to a cancellation fee or may not be refundable, depending on the nature of the product and preparations made.</p><p class="ar" dir="rtl"><strong>الإلغاءات:</strong> يمكن عادةً إلغاء الطلبات حتى [مثلاً، 48 ساعة] قبل وقت التسليم/الاستلام المقرر لاسترداد كامل المبلغ، مخصومًا منه أي تكاليف غير قابلة للاسترداد تم تكبدها بالفعل (مثل التقطيع المخصص لطلبات اللحوم). قد تخضع الإلغاءات التي تتم بإشعار أقل لرسوم إلغاء أو قد لا تكون قابلة للاسترداد، اعتمادًا على طبيعة المنتج والاستعدادات التي تم إجراؤها.</p></div></li>
            <li><div class="bil-row"><p class="en"><strong>Quality Issues:</strong> We take great care in ensuring the quality of our products. If you receive a product that does not meet our quality standards, please contact us within [e.g., 12 hours for fresh meat, 24 hours for live animals] of receipt with clear photographic evidence and a description of the issue. We will assess the situation on a case-by-case basis and may offer a replacement, partial refund, or full refund at our discretion.</p><p class="ar" dir="rtl"><strong>مشاكل الجودة:</strong> نحن نحرص بشدة على ضمان جودة منتجاتنا. إذا استلمت منتجًا لا يفي بمعايير الجودة لدينا، فيرجى الاتصال بنا في غضون [مثلاً، 12 ساعة للحوم الطازجة، 24 ساعة للحيوانات الحية] من الاستلام مع تقديم دليل فوتوغرافي واضح ووصف للمشكلة. سنقوم بتقييم الموقف على أساس كل حالة على حدة وقد نقدم بديلاً أو استردادًا جزئيًا أو كاملاً وفقًا لتقديرنا.</p></div></li>
        </ul>
        <h3 class="bil-spread modal-section-title"><span class="en">General Terms for Refunds</span><span class="ar" dir="rtl">الشروط العامة للاسترداد</span></h3>
        <div class="bil-row"><p class="en">All approved refund requests will be processed within [e.g., 7-14 business days]. Refunds will typically be made to the original method of payment if possible. If not, an alternative method will be arranged with you.</p><p class="ar" dir="rtl">ستتم معالجة جميع طلبات الاسترداد المعتمدة في غضون [مثلاً، 7-14 يوم عمل]. سيتم رد المبالغ عادةً إلى طريقة الدفع الأصلية إذا أمكن ذلك. إذا لم يكن ذلك ممكنًا، فسيتم ترتيب طريقة بديلة معك.</p></div>
        <div class="bil-row"><p class="en">Please note that any bank charges or transaction fees incurred during the payment process are generally non-refundable.</p><p class="ar" dir="rtl">يرجى ملاحظة أن أي رسوم بنكية أو رسوم معاملات يتم تكبدها أثناء عملية الدفع غير قابلة للاسترداد بشكل عام.</p></div>
        <div class="bil-row"><p class="en">Sheep Land reserves the right to modify this Refund & Cancellation Policy at any time. Any changes will be effective immediately upon posting on our website. Please check this page periodically for updates.</p><p class="ar" dir="rtl">تحتفظ أرض الأغنام بالحق في تعديل سياسة الاسترداد والإلغاء هذه في أي وقت. ستكون أي تغييرات سارية المفعول فور نشرها على موقعنا. يرجى مراجعة هذه الصفحة بشكل دوري للاطلاع على التحديثات.</p></div>
        <div class="bil-row"><p class="en">If you have any questions regarding our Refund & Cancellation Policy, please do not hesitate to contact us through the contact details provided on our website *before* placing your order.</p><p class="ar" dir="rtl">إذا كانت لديك أي أسئلة بخصوص سياسة الاسترداد والإلغاء الخاصة بنا، فيرجى عدم التردد في الاتصال بنا عبر تفاصيل الاتصال المتوفرة على موقعنا *قبل* تقديم طلبك.</p></div>
    `;

    // Collections WITHOUT relations (step 1 for schema creation)
    const collectionsWithoutRelations = [
        {
            name: "settings",
            type: "base",
            system: false,
            listRule: "@everyone",
            viewRule: "@everyone",
            createRule: null,
            updateRule: "@request.auth.id != '' && @request.auth.verified = true",
            deleteRule: null,
            schema: [ 
                { name: "xchgRates", type: "json", required: true, presentable: true, options: {} }, 
                { name: "defCurr", type: "text", required: true, presentable: true, options: {max: 5, min: 3} },
                { name: "waNumRaw", type: "text", required: false, presentable: true, options: {max: 20} }, 
                { name: "waNumDisp", type: "text", required: false, presentable: true, options: {max: 30} },
                { name: "promoEndISO", type: "date", required: false, presentable: true, options: {} }, 
                { name: "promoDiscPc", type: "number", required: false, presentable: true, options: {min: 0, max: 100} },
                { name: "promoActive", type: "bool", required: false, presentable: true, options: {default: false} }, 
                { name: "servFeeEGP", type: "number", required: true, presentable: true, options: {min: 0} },
                { name: "delAreas", type: "json", required: false, presentable: true, options: {} }, 
                { name: "payDetails", type: "json", required: false, presentable: true, options: {} },
                { name: "enable_udheya_section", type: "bool", required: false, presentable: true, options: {default: true}}, 
                { name: "enable_livestock_section", type: "bool", required: false, presentable: true, options: {default: true} },
                { name: "enable_meat_section", type: "bool", required: false, presentable: true, options: {default: true} }, 
                { name: "enable_gatherings_section", type: "bool", required: false, presentable: true, options: {default: true} },
                { name: "slaughter_location_gmaps_url", type: "url", required: false, presentable: true, options: {} },
                { name: "online_payment_fee_egp", type: "number", required: false, presentable: true, options: {min: 0} },
                { name: "refund_policy_html", type: "text", required: false, presentable: false, options: { editor: true } },
                { name: "app_email_sender_address", type: "email", required: false, presentable: false, options: {} },
                { name: "app_email_sender_name", type: "text", required: false, presentable: false, options: {max: 100} }
            ]
        },
        {
            name: "products", 
            type: "base", 
            system: false,
            listRule: "@everyone", 
            viewRule: "@everyone", 
            createRule: "@request.auth.id != '' && @request.auth.verified = true", 
            updateRule: "@request.auth.id != '' && @request.auth.verified = true", 
            deleteRule: "@request.auth.id != '' && @request.auth.verified = true",
            schema: [
                { name: "item_key", type: "text", system: false, required: true, presentable: true, unique: true, options: {max: 100, min: 1, pattern: "^[a-z0-9_]+$"} },
                { name: "product_category", type: "select", system: false, required: true, presentable: true, options: {maxSelect: 1, values: ["udheya", "livestock_general", "meat_cuts", "gathering_package", "other"]} },
                { name: "type_key", type: "text", system: false, required: true, presentable: true, options: {max: 50, min: 1, pattern: "^[a-z0-9_]+$"} },
                { name: "type_name_en", type: "text", system: false, required: true, presentable: true, options: {max: 100, min: 1} }, 
                { name: "type_name_ar", type: "text", system: false, required: true, presentable: true, options: {max: 100, min: 1} },
                { name: "type_description_en", type: "text", system: false, required: false, presentable: true, options: {max: 300} }, 
                { name: "type_description_ar", type: "text", system: false, required: false, presentable: true, options: {max: 300} },
                { name: "price_per_kg_egp", type: "number", system: false, required: false, presentable: true, options: {min: 0} },
                { name: "variant_name_en", type: "text", system: false, required: true, presentable: true, options: {max: 150, min: 1} },
                { name: "variant_name_ar", type: "text", system: false, required: true, presentable: true, options: {max: 150, min: 1} }, 
                { name: "weight_range_text_en", type: "text", system: false, required: false, presentable: true, options: {max: 50} },
                { name: "weight_range_text_ar", type: "text", system: false, required: false, presentable: true, options: {max: 50} }, 
                { name: "avg_weight_kg", type: "number", system: false, required: false, presentable: true, options: {min: 0} },
                { name: "base_price_egp", type: "number", system: false, required: true, presentable: true, options: {min: 0} }, 
                { name: "stock_available_pb", type: "number", system: false, required: true, presentable: true, options: {min: 0, noDecimal: true} },
                { name: "is_active", type: "bool", system: false, required: false, presentable: true, options: {default: true} }, 
                { name: "sort_order_type", type: "number", system: false, required: false, presentable: true, options: {min: 0, noDecimal: true} },
                { name: "sort_order_variant", type: "number", system: false, required: false, presentable: true, options: {min: 0, noDecimal: true} }
            ],
            indexes: [ "CREATE UNIQUE INDEX `idx_products_item_key` ON `products` (`item_key`)", "CREATE INDEX `idx_products_category` ON `products` (`product_category`)" ]
        },
        { // Auth collection (users) - define custom fields, system fields auto-added
            name: "users", // This will target the existing _pb_users_auth_
            type: "auth",
            system: false, // This is a user-defined representation, PB handles the system nature
            listRule: "@request.auth.id = id", // Users can list/view their own, admin can view all
            viewRule: "@request.auth.id = id",
            createRule: "", // Public registration
            updateRule: "@request.auth.id = id", // Users can update their own
            deleteRule: "@request.auth.id = id", // Users can delete their own (or null for admin only)
            options: { // These are options for the auth collection itself
                emailVisibility: true, // Admin can see emails
                requireEmailVerification: false, // Set to false for easier testing initially
                allowOAuth2Auth: false,
                allowUsernameAuth: false, // Only email/pass
                allowPasswordAuth: true,
                onlyVerified: false // Allow unverified users to log in initially
            },
            schema: [ // Only custom fields here
                { name: "name", type: "text", system: false, required: false, presentable: true, options: { max: 100 } },
                // Add other custom user fields like phone, address if needed later
                // Example: { name: "phone", type: "text", system: false, required: false, presentable: true, options: {max: 30} }
            ]
        },
        { // Orders collection (no relation fields in this initial step)
            name: "orders", 
            type: "base", 
            system: false,
            listRule: "(@request.auth.id != '' && user = @request.auth.id) || (order_id_text = @request.query.lookupOrderID && @request.query.lookupOrderID != '')", 
            viewRule: "(@request.auth.id != '' && user = @request.auth.id) || (order_id_text = @request.query.lookupOrderID && @request.query.lookupOrderID != '')",
            createRule: "", 
            updateRule: "@request.auth.id != '' && @request.auth.verified = true", 
            deleteRule: "@request.auth.id != '' && @request.auth.verified = true", 
            schema: [
                { name: "order_id_text", type: "text", system: false, required: true, presentable: true, unique: true, options: {max: 50, min: 1} },
                // user field will be added as relation later
                { name: "customer_name", type: "text", system: false, required: true, presentable: true, options: {max: 150, min: 1} },
                { name: "customer_phone", type: "text", system: false, required: true, presentable: true, options: {max: 30, min: 7} },
                { name: "customer_email", type: "email", system: false, required: true, presentable: true, options: {} },
                { name: "line_items", type: "json", system: false, required: true, presentable: true, options: {} }, 
                { name: "delivery_option", type: "select", system: false, required: true, presentable: true, options: {maxSelect:1, values:["home_delivery", "self_pickup_or_internal_distribution"]} },
                { name: "delivery_city_id", type: "text", system: false, required: false, presentable: true, options: {max: 50} },
                { name: "delivery_area_name_en", type: "text", system: false, required: false, presentable: true, options: {max:100} },
                { name: "delivery_area_name_ar", type: "text", system: false, required: false, presentable: true, options: {max:100} },
                { name: "delivery_address", type: "text", system: false, required: false, presentable: true, options: {max: 500} },
                { name: "delivery_instructions", type: "text", system: false, required: false, presentable: true, options: {max: 500} },
                { name: "delivery_time_slot", type: "text", system: false, required: false, presentable: true, options: {max: 50} },
                { name: "payment_method", type: "text", system: false, required: true, presentable: true, options: {max: 50, min: 1} },
                { name: "payment_status", type: "select", system: false, required: true, presentable: true, options: {maxSelect: 1, values: ["pending_payment", "payment_under_review", "paid_confirmed", "cod_pending_confirmation", "cod_confirmed_pending_delivery", "failed", "refunded", "partially_refunded", "pending_gateway_redirect"]} },
                { name: "order_status", type: "select", system: false, required: true, presentable: true, options: {maxSelect: 1, values: ["pending_confirmation", "confirmed_pending_payment", "payment_confirmed_processing", "ready_for_fulfillment", "out_for_delivery", "fulfilled_completed", "cancelled_by_user", "cancelled_by_admin", "on_hold", "awaiting_payment_gateway"]} },
                { name: "terms_agreed", type: "bool", system: false, required: true, presentable: true, options: {} },
                { name: "admin_notes", type: "text", system: false, required: false, presentable: false, options: {max: 1000, editor: true} },
                { name: "user_ip_address", type: "text", system: false, required: false, presentable: false, options: {max: 50} },
                { name: "user_agent_string", type: "text", system: false, required: false, presentable: false, options: {max: 300} },
                { name: "subtotal_amount_egp", type: "number", system: false, required: true, presentable: true, options: {min:0} },
                { name: "total_udheya_service_fee_egp", type: "number", system: false, required: false, presentable: true, options: {min:0} },
                { name: "delivery_fee_applied_egp", type: "number", system: false, required: false, presentable: true, options: {min:0} },
                { name: "online_payment_fee_applied_egp", type: "number", system: false, required: false, presentable: true, options: {min:0} },
                { name: "total_amount_due_egp", type: "number", system: false, required: true, presentable: true, options: {min: 0} },
                { name: "selected_display_currency", type: "text", system: false, required: false, presentable: true, options: {max: 5} }
            ],
            indexes: [ "CREATE UNIQUE INDEX `idx_orders_order_id_text` ON `orders` (`order_id_text`)"] // user index will be added with relation
        }
    ];

    const seedData = {
        settings: [{
            xchgRates: { EGP: { rate_from_egp: 1, symbol: "LE", is_active: true }, USD: { rate_from_egp: 0.020, symbol: "$", is_active: true }, GBP: { rate_from_egp: 0.015, symbol: "£", is_active: true }, EUR: { rate_from_egp: 0.018, symbol: "€", is_active: true } },
            defCurr: "EGP", waNumRaw: "201117117489", waNumDisp: "+20 11 1711 7489", 
            promoEndISO: new Date(Date.now() + 15 * 24 * 60 * 60 * 1000).toISOString(), 
            promoDiscPc: 10, promoActive: true, servFeeEGP: 750,
            delAreas: [ { id: "giza_west", name_en: "Giza West", name_ar: "غرب الجيزة", cities: [ { id: "october", name_en: "6th of October City", name_ar: "مدينة 6 أكتوبر", delivery_fee_egp: 150 }, { id: "zayed", name_en: "Sheikh Zayed", name_ar: "الشيخ زايد", delivery_fee_egp: 150 }, { id: "hadayek_october", name_en: "Hadayek October", name_ar: "حدائق أكتوبر", delivery_fee_egp: 120 } ] }, { id:"cairo_east", name_en:"Cairo East", name_ar:"شرق القاهرة", cities:[ {id:"tagamoa", name_en:"New Cairo (Tagamoa)", name_ar:"التجمع (القاهرة الجديدة)", delivery_fee_egp: 250 }, {id:"madinaty", name_en:"Madinaty", name_ar:"مدينتي", delivery_fee_egp: 300 }, {id:"shorouk", name_en:"El Shorouk", name_ar:"الشروق", delivery_fee_egp: 300} ] } ],
            payDetails: { vodafone_cash: "01076543210", instapay_ipn: "seed_user@instapay", revolut_details: "@seedUserRevolut", monzo_details: "monzo.me/seeduser", bank_name: "Seed Bank Egypt", bank_account_name: "Sheep Land Seed Account", bank_account_number: "1234567890123456", bank_iban: "EG00123400000000001234567890", bank_swift: "SEEDBANKEGCA" },
            enable_udheya_section: true, enable_livestock_section: true, enable_meat_section: true, enable_gatherings_section: true,
            slaughter_location_gmaps_url: "https://maps.app.goo.gl/GmWajZfqzPh4ZAey7", online_payment_fee_egp: 35,
            refund_policy_html: defaultRefundPolicyHTMLForSeed, app_email_sender_address: "noreply@sheepland.example.com", app_email_sender_name: "Sheep Land Orders"
        }],
        products: [
            { item_key: "baladi_udheya_45kg", product_category: "udheya", type_key: "baladi", type_name_en: "Baladi Udheya Sheep", type_name_ar: "خروف بلدي للأضحية", type_description_en: "Local breed, excellent for Udheya, known for its marbling and taste.", type_description_ar: "سلالة محلية، ممتازة للأضحية، معروفة بدهونها المتداخلة وطعمها الغني.", price_per_kg_egp: 230, variant_name_en: "Baladi Udheya (Approx. 45kg)", variant_name_ar: "أضحية بلدي (تقريباً ٤٥ كجم)", weight_range_text_en: "40-50kg", weight_range_text_ar: "٤٠-٥٠ كجم", avg_weight_kg: 45, base_price_egp: 10350, stock_available_pb: 10, is_active: true, sort_order_type: 1, sort_order_variant: 1 },
            { item_key: "baladi_udheya_55kg", product_category: "udheya", type_key: "baladi", type_name_en: "Baladi Udheya Sheep", type_name_ar: "خروف بلدي للأضحية", type_description_en: "Larger local breed, excellent for Udheya.", type_description_ar: "سلالة محلية أكبر حجمًا، ممتازة للأضحية.", price_per_kg_egp: 230, variant_name_en: "Baladi Udheya (Approx. 55kg)", variant_name_ar: "أضحية بلدي (تقريباً ٥٥ كجم)", weight_range_text_en: "50-60kg", weight_range_text_ar: "٥٠-٦٠ كجم", avg_weight_kg: 55, base_price_egp: 12650, stock_available_pb: 8, is_active: true, sort_order_type: 1, sort_order_variant: 2 },
            { item_key: "barki_udheya_50kg", product_category: "udheya", type_key: "barki", type_name_en: "Barki Udheya Sheep", type_name_ar: "خروف برقي للأضحية", type_description_en: "Desert breed, lean and flavorful meat, popular for Udheya.", type_description_ar: "سلالة صحراوية، لحم قليل الدهن وذو نكهة مميزة، شائع للأضحية.", price_per_kg_egp: 250, variant_name_en: "Barki Udheya (Approx. 50kg)", variant_name_ar: "أضحية برقي (تقريباً ٥٠ كجم)", weight_range_text_en: "45-55kg", weight_range_text_ar: "٤٥-٥٥ كجم", avg_weight_kg: 50, base_price_egp: 12500, stock_available_pb: 12, is_active: true, sort_order_type: 2, sort_order_variant: 1 },
            { item_key: "live_ram_baladi_large", product_category: "livestock_general", type_key: "live_ram", type_name_en: "Live Baladi Ram", type_name_ar: "كبش بلدي حي", type_description_en: "Large healthy Baladi ram for breeding or other purposes.", type_description_ar: "كبش بلدي كبير صحي للتربية أو أغراض أخرى.", variant_name_en: "Large Baladi Ram (70-80kg)", variant_name_ar: "كبش بلدي كبير (٧٠-٨٠كجم)", base_price_egp: 15000, stock_available_pb: 3, is_active: true, sort_order_type: 3, sort_order_variant: 1 },
            { item_key: "live_ewe_barki_medium", product_category: "livestock_general", type_key: "live_ewe", type_name_en: "Live Barki Ewe", type_name_ar: "نعجة برقي حية", type_description_en: "Healthy Barki ewe, excellent for breeding programs.", type_description_ar: "نعجة برقي صحية، ممتازة لبرامج التربية.", variant_name_en: "Medium Barki Ewe (50-60kg)", variant_name_ar: "نعجة برقي متوسطة (٥٠-٦٠كجم)", base_price_egp: 9500, stock_available_pb: 5, is_active: true, sort_order_type: 3, sort_order_variant: 2 },
            { item_key: "lamb_chops_kg", product_category: "meat_cuts", type_key: "lamb_cuts", type_name_en: "Lamb Cuts", type_name_ar: "قطعيات ضأن", type_description_en: "Fresh premium lamb chops, tender and juicy.", type_description_ar: "ريش ضأن طازجة فاخرة، طرية وغنية بالعصارة.", variant_name_en: "Lamb Chops (per kg)", variant_name_ar: "ريش ضاني (للكيلو)", weight_range_text_en: "Per kg", weight_range_text_ar: "للكيلو", base_price_egp: 450, stock_available_pb: 15, is_active: true, sort_order_type: 4, sort_order_variant: 1 },
            { item_key: "lamb_leg_whole", product_category: "meat_cuts", type_key: "lamb_cuts", type_name_en: "Lamb Cuts", type_name_ar: "قطعيات ضأن", type_description_en: "Whole lamb leg, perfect for roasting or special meals.", type_description_ar: "فخذة ضأن كاملة، مثالية للتحمير أو الوجبات الخاصة.", variant_name_en: "Whole Lamb Leg (Approx. 2-3kg)", variant_name_ar: "فخذة ضاني كاملة (تقريباً ٢-٣ كجم)", avg_weight_kg: 2.5, base_price_egp: 1100, stock_available_pb: 7, is_active: true, sort_order_type: 4, sort_order_variant: 2 },
            { item_key: "beef_mince_kg", product_category: "meat_cuts", type_key: "beef_cuts", type_name_en: "Beef Cuts", type_name_ar: "قطعيات بقري", type_description_en: "Freshly ground local beef, versatile for many dishes.", type_description_ar: "لحم بقري محلي مفروم طازج، متعدد الاستخدامات للعديد من الأطباق.", variant_name_en: "Beef Mince (per kg)", variant_name_ar: "لحم بقري مفروم (للكيلو)", weight_range_text_en: "Per kg", weight_range_text_ar: "للكيلو", base_price_egp: 380, stock_available_pb: 20, is_active: true, sort_order_type: 4, sort_order_variant: 3 },
            { item_key: "gathering_feast_medium", product_category: "gathering_package", type_key: "feast_pack", type_name_en: "Medium Feast Package", type_name_ar: "باقة وليمة متوسطة", type_description_en: "Complete package for a medium gathering. Includes one processed sheep (approx 50kg live weight), rice, and salads.", type_description_ar: "باقة متكاملة لوليمة متوسطة. تشمل خروف مجهز (وزن حي تقريباً ٥٠ كجم)، أرز، وسلطات.", variant_name_en: "Medium Feast (serves 15-20)", variant_name_ar: "وليمة متوسطة (تكفي ١٥-٢٠ فرد)", base_price_egp: 14500, stock_available_pb: 5, is_active: true, sort_order_type: 5, sort_order_variant: 1 },
            { item_key: "gathering_bbq_large", product_category: "gathering_package", type_key: "bbq_pack", type_name_en: "Large BBQ Package", type_name_ar: "باقة شواء كبيرة", type_description_en: "Generous assortment of marinated meats, skewers, and sides for a large BBQ event.", type_description_ar: "تشكيلة وفيرة من اللحوم المتبلة، الأسياخ، والأطباق الجانبية لحفل شواء كبير.", variant_name_en: "Large BBQ Pack (serves 20-25)", variant_name_ar: "باقة شواء كبيرة (تكفي ٢٠-٢٥ فردًا)", base_price_egp: 4500, stock_available_pb: 8, is_active: true, sort_order_type: 5, sort_order_variant: 2 }
        ]
    };

    async function authenticateAdmin(pb) {
        try {
            log(`Attempting admin authentication with: ${ADM_E}...`, 'i');
            await pb.admins.authWithPassword(ADM_E, ADM_P);
            log('Admin authentication successful', 's');
            return true;
        } catch (error) {
            log(`Authentication failed: ${error.message}`, 'e');
            console.error('Auth error:', error);
            if (error.response?.data) log('Auth error details:', 'e', error.response.data);
            return false;
        }
    }

    async function importOrUpdateCollections(pb, collections) {
        log('Starting collection schema setup/update...', 'i');
        for (const collectionDef of collections) {
            let existingCollection = null;
            try {
                existingCollection = await pb.collections.getOne(collectionDef.name);
                log(`Collection "${collectionDef.name}" exists. Attempting update...`, 'i');
                const updatePayload = { // Construct payload for update
                    schema: collectionDef.schema,
                    listRule: collectionDef.listRule,
                    viewRule: collectionDef.viewRule,
                    createRule: collectionDef.createRule,
                    updateRule: collectionDef.updateRule,
                    deleteRule: collectionDef.deleteRule,
                    // Indexes are tricky to update via API, usually done via migrations
                    // For initial setup, this might work for some simple index cases if PB API supports it in import.
                    // For updates, it's safer to manage indexes manually or through migrations.
                };
                 if (collectionDef.indexes) { // Only add if defined to avoid errors
                    updatePayload.indexes = collectionDef.indexes;
                }
                await pb.collections.update(collectionDef.name, updatePayload);
                log(`Collection "${collectionDef.name}" updated successfully.`, 's');

            } catch (e) {
                if (e.status === 404) { // Collection does not exist, create it
                    log(`Collection "${collectionDef.name}" not found. Creating...`, 'i');
                    try {
                         const newCollectionData = {
                            name: collectionDef.name,
                            type: collectionDef.type,
                            system: collectionDef.system || false,
                            schema: collectionDef.schema,
                            listRule: collectionDef.listRule,
                            viewRule: collectionDef.viewRule,
                            createRule: collectionDef.createRule,
                            updateRule: collectionDef.updateRule,
                            deleteRule: collectionDef.deleteRule,
                            indexes: collectionDef.indexes || [],
                            options: collectionDef.options || {} // For auth collections
                        };
                        await pb.collections.import([newCollectionData], false); // Import expects an array
                        log(`Collection "${collectionDef.name}" created successfully.`, 's');
                    } catch (createError) {
                        log(`Error CREATING collection "${collectionDef.name}": ${createError.message}`, 'e', createError.data);
                        return false; // Stop if a collection creation fails
                    }
                } else { // Other error during getOne or update
                    log(`Error processing collection "${collectionDef.name}": ${e.message}`, 'e', e.data);
                    return false; // Stop if any other error occurs
                }
            }
            await new Promise(r => setTimeout(r, 100)); // Small delay
        }
        log('All collections processed.', 's');
        return true;
    }
    
    async function addRelationFields(pb) {
        log('Adding/Verifying relation fields...', 'i');
        let success = true;
        const relationsToAdd = [
            { 
                sourceCollectionName: "orders", 
                fieldName: "user", 
                targetCollectionName: "_pb_users_auth_", // This is the system name for users
                options: { cascadeDelete: false, minSelect: null, maxSelect: 1, displayFields: ["email", "name"] },
                required: false, // Orders can be by guests
                presentable: true
            }
            // Add more relations here if needed in the future
        ];

        for (const rel of relationsToAdd) {
            try {
                const sourceCollection = await pb.collections.getOne(rel.sourceCollectionName);
                const fieldExists = sourceCollection.schema.find(f => f.name === rel.fieldName);

                if (fieldExists) {
                    log(`Relation field "${rel.fieldName}" already exists in "${rel.sourceCollectionName}". Skipping.`, 'w');
                    continue;
                }
                
                // Fetch target collection to get its ID for the relation options
                // For "_pb_users_auth_", its ID is literally "users" for older PB versions, or its actual system ID for newer.
                // The SDK handles "_pb_users_auth_" directly in options.collectionId
                const newField = {
                    name: rel.fieldName,
                    type: "relation",
                    required: rel.required,
                    presentable: rel.presentable,
                    system: false,
                    unique: false,
                    options: {
                        collectionId: rel.targetCollectionName, // Use the name, SDK resolves it
                        cascadeDelete: rel.options.cascadeDelete,
                        minSelect: rel.options.minSelect,
                        maxSelect: rel.options.maxSelect,
                        displayFields: rel.options.displayFields
                    }
                };
                
                const updatedSchema = [...sourceCollection.schema, newField];
                await pb.collections.update(sourceCollection.id, { schema: updatedSchema });
                log(`Relation field "${rel.fieldName}" added to "${rel.sourceCollectionName}" successfully.`, 's');

            } catch (error) {
                log(`Error adding relation field "${rel.fieldName}" to "${rel.sourceCollectionName}": ${error.message}`, 'e', error.data);
                success = false;
            }
            await new Promise(r => setTimeout(r, 100)); // Small delay
        }
        return success;
    }


    async function seedCollectionData(pb, collectionName, seedItems, uniqueKeyField = null) {
        log(`Seeding data for <b>${collectionName}</b>...`, 'i');
        let createdCount = 0, updatedCount = 0, errorCount = 0;
        
        for (const item of seedItems) {
            try {
                let existingRecord = null;
                if (uniqueKeyField && item[uniqueKeyField] !== undefined) { // Check if uniqueKeyField actually exists on item
                    try { 
                        existingRecord = await pb.collection(collectionName).getFirstListItem(`${uniqueKeyField}="${item[uniqueKeyField]}"`); 
                    } catch (e) { /* Record doesn't exist, will create */ }
                } else if (!uniqueKeyField && collectionName === "settings") { 
                    const list = await pb.collection(collectionName).getList(1, 1);
                    if (list.items.length > 0) existingRecord = list.items[0];
                }

                if (existingRecord) {
                    await pb.collection(collectionName).update(existingRecord.id, item);
                    updatedCount++;
                } else {
                    await pb.collection(collectionName).create(item);
                    createdCount++;
                }
            } catch (error) {
                log(`Error processing item in ${collectionName} (${item[uniqueKeyField] || 'new item'}): ${error.message}`, 'e');
                console.error('Seed error:', error);
                if (error.response?.data) log('Seed error details:', 'e', error.response.data);
                errorCount++;
            }
        }
        log(`Seeding <b>${collectionName}</b> complete. Created: ${createdCount}, Updated: ${updatedCount}, Errors: ${errorCount}`, errorCount > 0 ? 'w' : 's');
        return { created: createdCount, updated: updatedCount, errors: errorCount };
    }

    async function setupSchema(pb) {
        log('=== SCHEMA SETUP PHASE ===', 'i');
        if (!await authenticateAdmin(pb)) return false;

        // Step 1: Create/Update collections without relations first (or ensure 'users' is configured)
        log('Processing initial collections (settings, products, users config)...', 'i');
        if (!await importOrUpdateCollections(pb, collectionsWithoutRelations.filter(c => c.name !== 'orders'))) { // Exclude orders for now
             log('Initial collection setup failed.', 'e'); return false;
        }
        
        // Step 2: Create/Update 'orders' collection (which might have relations to be added later)
        log('Processing "orders" collection schema...', 'i');
        const ordersDef = collectionsWithoutRelations.find(c => c.name === 'orders');
        if (ordersDef) {
            if (!await importOrUpdateCollections(pb, [ordersDef])) {
                log('"orders" collection setup failed.', 'e'); return false;
            }
        } else {
            log('Definition for "orders" collection not found. Skipping.', 'w');
        }

        // Step 3: Add relation fields
        log('Processing relation fields...', 'i');
        if (!await addRelationFields(pb)) {
             log('Relation field setup failed.', 'e'); return false;
        }

        log('Schema setup completed successfully', 's');
        return true;
    }

    async function setupSeedData(pb) {
        log('=== SEED DATA PHASE ===', 'i');
        if (!await authenticateAdmin(pb)) return false;

        log('Pausing for 1 second before seeding...', 'i');
        await new Promise(resolve => setTimeout(resolve, 1000));

        let anySeedErrors = false;
        const settingsResult = await seedCollectionData(pb, 'settings', seedData.settings);
        if(settingsResult.errors > 0) anySeedErrors = true;

        const productsResult = await seedCollectionData(pb, 'products', seedData.products, 'item_key');
        if(productsResult.errors > 0) anySeedErrors = true;
        
        if (anySeedErrors) {
            log('Seed data setup completed with errors.', 'w');
            return false;
        }
        log('Seed data setup completed successfully', 's');
        return true;
    }
    
    function validateProductionSecurity() {
        const warnings = [];
        collectionsDefinition.forEach(collection => {
            if (collection.listRule === "" || collection.createRule === "" || 
                collection.updateRule === "" || collection.deleteRule === "") {
                if (collection.name !== "settings" && collection.name !== "products") { // Allow public read for settings and products
                     if(!(collection.listRule === "@everyone" && collection.viewRule === "@everyone" && collection.createRule === null && collection.updateRule === null && collection.deleteRule === null) &&
                        !(collection.listRule === "" && collection.viewRule === "" && collection.createRule === null && collection.updateRule === null && collection.deleteRule === null) ) {
                           // This logic needs refinement based on which collections are truly public vs. which need auth for some operations.
                           // For now, let's focus on a simpler warning.
                     }
                }
            }
            if (collection.type === "auth" && collection.name === "users") { // Specifically for users collection
                if (collection.createRule === "") warnings.push(`Auth Collection '${collection.name}' has public createRule (open registration). Ensure this is intended.`);
                if (collection.options && collection.options.requireEmailVerification === false) {
                    warnings.push(`Auth Collection '${collection.name}' has 'requireEmailVerification' set to false. Recommended to enable for production.`);
                }
            }
        });
        
        if (ADM_E === 'admin@example.com' && ADM_P === 'unifiedpassword') {
            warnings.push('Using default admin credentials (admin@example.com / unifiedpassword) - CHANGE FOR PRODUCTION!');
        }
        
        if (warnings.length > 0) {
            log('🚨 PRODUCTION SECURITY WARNINGS:', 'e');
            warnings.forEach(warning => log(`⚠️  ${warning}`, 'w'));
            log('🚨 REVIEW AND SECURE THESE BEFORE PRODUCTION DEPLOYMENT', 'e');
        } else {
            log('✓ Production security preliminary checks passed (review rules manually).', 's');
        }
        return warnings.length === 0;
    }


    runFullSetupButton.onclick = async () => {
        [runFullSetupButton, runSchemaOnlyButton, runSeedOnlyButton].forEach(b => b.disabled = true);
        outputDiv.innerHTML = ''; log('=== FULL SETUP PROCESS STARTED ===', 'i');
        const pb = new PocketBase(pbUrl);
        let schemaSuccess = false;
        try {
            schemaSuccess = await setupSchema(pb);
            if (!schemaSuccess) {
                log('Schema setup failed, aborting full setup', 'e');
                return;
            }

            const seedSuccess = await setupSeedData(pb);
            if (!seedSuccess) {
                log('Seed data setup failed, but schema might be okay.', 'w');
            }

            log('<b>=== FULL SETUP COMPLETED ===</b>', 's');
            validateProductionSecurity();
            runSeedOnlyButton.disabled = !schemaSuccess; 
        } catch (error) {
            log(`<b>CRITICAL ERROR during full setup:</b> ${error.message}`, 'e');
            console.error('Full setup error:', error);
            if (error.response?.data) log('Full setup error details:', 'e', error.response.data);
            if (error.stack) log('Stack trace:', 'e', error.stack);
        } finally {
            if (pb.authStore.isValid) pb.authStore.clear();
            [runFullSetupButton, runSchemaOnlyButton].forEach(b => b.disabled = false);
            log('Process finished, auth cleared', 'i');
        }
    };

    runSchemaOnlyButton.onclick = async () => {
        [runFullSetupButton, runSchemaOnlyButton, runSeedOnlyButton].forEach(b => b.disabled = true);
        outputDiv.innerHTML = ''; 
        log('=== SCHEMA ONLY SETUP STARTED ===', 'i');
        const pb = new PocketBase(pbUrl);
        try {
            const success = await setupSchema(pb);
            if (success) {
                runSeedOnlyButton.disabled = false;
                log('<b>Schema setup completed successfully</b>', 's');
                validateProductionSecurity();
            } else {
                 log('<b>Schema setup FAILED</b>', 'e');
            }
        } catch (error) {
            log(`<b>ERROR during schema setup:</b> ${error.message}`, 'e');
            console.error('Schema error:', error);
            if (error.response?.data) log('Schema error details:', 'e', error.response.data);
        } finally {
            if (pb.authStore.isValid) pb.authStore.clear();
            [runFullSetupButton, runSchemaOnlyButton].forEach(b => b.disabled = false);
             log('Schema only process finished, auth cleared', 'i');
        }
    };

    runSeedOnlyButton.onclick = async () => {
        [runFullSetupButton, runSchemaOnlyButton, runSeedOnlyButton].forEach(b => b.disabled = true);
        outputDiv.innerHTML = ''; 
        log('=== SEED DATA ONLY STARTED ===', 'i');
        const pb = new PocketBase(pbUrl);
        try {
            const success = await setupSeedData(pb);
             if (success) {
                log('<b>Seed data setup completed successfully</b>', 's');
            } else {
                 log('<b>Seed data setup FAILED or completed with errors.</b>', 'w');
            }
        } catch (error) {
            log(`<b>ERROR during seed setup:</b> ${error.message}`, 'e');
            console.error('Seed error:', error);
            if (error.response?.data) log('Seed error details:', 'e', error.response.data);
        } finally {
            if (pb.authStore.isValid) pb.authStore.clear();
            [runFullSetupButton, runSchemaOnlyButton, runSeedOnlyButton].forEach(b => b.disabled = false);
            log('Seed data only process finished, auth cleared', 'i');
        }
    };
</script>
</body>
</html>
